<html>
<head>
<title>Flasck Front-End compiler</title>
</head>
<body>
<h1>Flasck Front-End parser/code generator</h1>
This is a parser and code-generator for flasck-like definitions in a functional context.
<p>
A specification will be found in a (missing) word doc.
<p>
The basic idea is to be able to build "cards" in a cardstack.org sense using functional definitions that are then converted into JavaScript by this compiler.
<p>
The input to the compiler is a set of files which are structured purely using indentation (there are no line terminators or block start and end characters).  A new block is introduced with an "extra" tab, and lines are continued by having the same number of tabs and one or more spaces.  This is all handled by the <a href='blocker.html'><tt>Blocker</tt></a>.
<p>
The output of the <tt>Blocker</tt> consists of a set of blocks, each of which has one <tt>ContinuedLine</tt> consisting in turn of one or more physical lines.  The physical lines are concatenated (with a space inserted) to make a single line definition (which could have been presented as one line in the first place).  A <a href='story.html'><tt>Story</tt></a> navigates the tree of blocks calling "potential" line parsers as appropriate and seeing which of these match and then operating accordingly on nested blocks.  This produces a tree of <a href='scope.html'><tt>Scope</tt></a>, each of which is a mapping from a name to a definition; each definition in turn may have a nested <tt>Scope</tt>.  This is described in the <a href='parser.html'><tt>Parser</tt></a>.
<p>
This is then translated into "virtual code" for a "virtual machine".  The exact translation and what gets left depends on the individual definitions, but the idea is that the final virtual code is mainly function definitions, together with enough information to understand how objects are laid out and how the functions exist within the overall environment (by which I basically mean types and interfaces).
<p>
So far, only the case for normal "functions" has been handled in the <a href='hsie.html'><tt>HSIE</tt></a> engine.
<p>
There needs to be a phase which then resolves the dependency graph.  Each function knows what objects it depends on, but these need to be ordered so that operations such as type checking can work in an orderly fashion.
<p>
With this virtual form in place, we are in a position to do type checking.  Our type checking algorithm is based on the "standard" inference engine first fully described by Hindley and Milner in 1978, but our version owes much more to the detailed implementation given by Peter Hancock in SLPJ's seminal work "The Implementation of Functional Programming Languages".  Since the original text is rather formal, significantly mathematical and very "computer science-y", it is somewhat translated in the section <a href='understanding_peter_hancock.html'>Understanding Peter Hancock</a>. 
<p>
With that understanding in place, I intend to go back and <a href='building_a_typechecker.html'>build a typechecker using TDD</a>, building up from the simplest cases (such as a simple, standalone lambda function) to the more complex cases (such as <tt>LETREC</tt>s).
<p>
With the necessary annotations from the type checker, it is then possible to <a href='codegen.html'>generate actual JavaScript</a> for the functions and cards, and connect to the broader card environment.
<p>
The JavaScript runtime is a separate project, see <a href='http://github.com/zinikiGareth/flasjs'><tt>http://github.com/zinikiGareth/flasjs</tt></a>. 
</body>
</html>
