<h1>Building a Typechecker</h1>
So, as per my understanding of the process, the first step is to create a TypeChecker class, which we'll put in a new package, org.flasck.flas.typechecker.  I don't think we're going to need a separate package for the "type checked form" because it can easily just fit inside the parsed form, if needed at all.  The initial definition of this class is just going to have a constructor, a typecheck method, and an <tt>ErrorResult</tt> to handle any errors.  To go with that, we obviously need a test case class.
<h2>Handling Numbers</h2>
Testing a function up front is just more complex than I want to try.  So first, let's deal with some expressions that (hopefully) are associated with known outputs.  Because of the way that he approaches his data model, PH sees everything as "an expression" and, interestingly enough, doesn't specifically deal with the "constant" case, which seems the simplest to me.
<p>
Since I'm dealing with a different data model, I'm going to introduce a new method to my TypeChecker class - <tt>tcExpr</tt> - which is responsible for attempting to determine the type of a single expression given everything it knows about the current state of the world.  I'm not sure that this is going to work out in the long run - it could be too big a deviation from the overall plan - but I'm sure we can refactor back to where we need to be.
<p>
In doing this, it becomes clear that we need a return type for <tt>tcExpr</tt>.  Since we're putting any errors we find in the <tt>ErrorResult</tt> object, the only real option here is the "valid" type of the expression - or null if typechecking fails.  It's easy enough to create "TypeExpr", but what goes into it?
<p>
PH discusses his representation of type expressions in PH9.2 and it seems easy enough to copy his definition and map it over into Java.  Basically, what he suggests is keeping track of types in much the way they are usually represented: a type "name" and a list of "type expression" arguments - for those types that need arguments.  There are then a couple of special types (which seem more common because of the presentation) for handling functions and tuples.  We will represent these by the types <tt>-></tt> and <tt>()</tt> to avoid clashing with any "normal" names; a type such as "Cons" would need one argument - the type of its <tt>head</tt> element.
<p>
There is also the option to typecheck something to just be a "type variable".  Since this is a completely different beast, we will use two different classes and have the tcExpr method return <tt>Object</tt>.  We can then wire up our typechecker to just directly say that any expression which has a numeric constant returns <tt>Number</tt> and voila! We're done. (See <tt>testWeCanTypecheckANumber</tt>).
<h2>Handling a Function</h2>
Because I'm not really sure what I'm doing, I'm next going to skip to the simplest function case I can think of - which corresponds to attempting to typecheck a lambda expression (PH9.7.4).  This appears to ease me into doing a lot of the more complex things without getting in too deep too quickly.
<p>
This requires us to understand type schemes, which were introduced in PH9.5 (q.v. and <a href='understanding_peter_hancock.html#typeSchemes'>my interpretation</a>).  I'm now going to go ahead and created the appropriate classes for <tt>TypeScheme</tt> and <tt>TypeVar</tt> in line with my understanding from that section.
<p>
We can create a type scheme, but in order to do that, we need the <tt>VariableFactory</tt> alluded to in <a href='understanding_peter_hancock.html#variableFactory'>UPH</a>.  This is just a simple bean counter that can issue unique new <tt>TypeVar</tt> objects.
<p>
OK, whoa there!  In defining this next test, I realize I want to use and typecheck HSIE formed expressions, not the parse form.  So, what I previously wrote as a test case won't work.  OK, I'll have to pull that back and rewrite it.  In the meantime, let's press on.
<p>
So, I created a new simple function in the HSIETestData set.  It takes one parameter - needed to obtain a <tt>LAMBDA</tt> expression - and returns the number 1 as a result.  It should have the type A->Number where "A" here represents a type variable.  The factory is actually issuing things that print <tt>tv_1</tt>, but that looks ugly, so I'm going with something better here.
<p>
Another wrinkle that promptly emerges is that PH folds all his lambdas to look like (&lambda;x.(&lambda;y.(&lambda;z.E(x,y,z))).  Since we have direct functions of multiple arguments, I am going to simply do "all of these" at once.
<p>
I had been thinking that I would be storing the equivalent of the "type environment" <tt>gamma</tt> (PH9.7) in the typechecker's state.  While it's true that I probably do want to store a significant amount of that state there, the "current portion" needs to be in a local variable so that we can push new entries onto it - for example, when binding a lambda expression.
<p>
So, backtracking to the first test case, we want to rewrite this a test of typechecking an HSIEBlock, specifically one that returns the number 1.  So let's do that, by extracting the expression from our newly defined test data.  We then need to look and see if the command is a <tt>RETURN</tt> of an integer, and, if so, return type <tt>Number</tt>.  OK, good.
<h2>Two random thoughts</h2>
I've been thinking a lot about how to interpret the pattern matching and switching that we do on the left hand sides of equations.  It seems like it adds information, but it's not really clear where that information goes or what we do with it.
<p>
I think the simple answer is that we just throw it away.  I think we need to know something about the <tt>BIND</tt> instructions so as to introduce the new variables, along with their types (although I'm still not sure how we do <i>that</i>).  But the important thing is to say that if a function <tt>f</tt> is to be consistently typed it must have a type v0->v1 for all the cases; i.e. that whatever the input types are (which we know for a specific case), the output type (i.e. the value of the function) must be the same.
<p>
Which brings me on to the other thing that's been bothering me.  I'm very concerned about the union types (e.g. <tt>List = Nil|Cons</tt>).  It's not clear if we can distinguish such a beast from a type error (this appears to be <tt>Nil</tt> here and <tt>Cons</tt> there - can we unify that).  Having studied <tt>TypeExpr</tt> in a bit more detail, it seems reasonable that we could <i>represent</i> a union type by the constructor <tt>||</tt> across a set of types.  But that still leaves the question of how to unify them.  I'm not even really sure where in the algorithm this pops up.  One possibility would be to "always" allow it, but I think that would allow too many invalid programs; one possibility would be to allow it whenever there was a suitable pre-defined union type (such as <tt>List</tt>), but I think that would too often devolve to <tt>Any</tt>; one possibility would be only allow it if there was a type which exactly matched the union when it was fully resolved at a "top level", but contrariwise I think that might have too many false negatives.
<h2>PHI</h2>
So, that leads us to what the appropriate return value should be from typechecking.  It seems intuitive to me that the correct thing to get back is a type, at least from an expression.  But somewhere in between, we have a logical deduction to make.  We start off by saying "we know what the type is, it is T7 or whatever".  We then have to solve this set of simultaneous equations to deduce what we mean by T7.  This is done in part of a larger computation of this magical function PHI.  This takes me back to trying to understand Mr. Hancock more thoroughly again.