<grammar title='FLAS Grammar'>
  <css href='grammar.css' />
  <burble name='preamble'>
    <p>FLAS is an actor-based functional language for cards.</p>
  </burble>
  <burble name='lex'>
    <h2>Lexical Issues</h2>
  </burble>
  <lex token='ACOR' pattern='acor'>
  	<p>The <tt>acor</tt> keyword introduces an object accessor function.</p>
  </lex>
  <lex token='APPLY' pattern='\.'>
  	<p>The apply operator.</p>
  </lex>
  <lex token='BINOP' pattern='[-+*/.]'>
  	<p>One of the standard binary operators.  They have precedence, but this is not apparent from the grammar.</p>
  	<p class='comment'>We should specify the precedence here.</p>
  </lex>
  <lex token='CARD' pattern='card'>
  	<p>The <tt>card</tt> keyword introduces a card definition.</p>
  </lex>
  <lex token='CCB' pattern='\}'>
  	<p>A closing curly bracket delimits the end of a constructor pattern or object creation.</p>
  </lex>
  <lex token='COLON' pattern=':'>
  	<p>Can be an operator or can be used to define object literals.</p>
  </lex>
  <lex token='COMMA' pattern=','>
  	<p>Separates similar items in a list.</p>
  </lex>
  <lex token='CONTRACT' pattern='contract'>
  	<p>The <tt>contract</tt> keyword introduces a contract declaration.</p>
  </lex>
  <lex token='CRB' pattern='\)'>
  	<p>A closing round bracket delimits the end of an expression or pattern.</p>
  </lex>
  <lex token='CSB' pattern='\]'>
  	<p>A closing square bracket delimits the end of a list operation or polymorphic variable list.</p>
  </lex>
  <lex token='CTOR' pattern='ctor'>
  	<p>The <tt>ctor</tt> keyword introduces an object constructor declaration.</p>
  </lex>
  <lex token='DEAL' pattern='deal'>
  	<p>The <tt>deal</tt> keyword introduces a deal declaration.</p>
  </lex>
  <lex token='DIR' pattern='up|down'>
  	<p>The <tt>up</tt> and <tt>down</tt> keywords indicate the sense in which a contract method is called.</p>
  </lex>
  <lex token='ENTITY' pattern='entity'>
  	<p>The <tt>entity</tt> keyword introduces an entity definition.</p>
  </lex>
  <lex token='ENVELOPE' pattern='envelope'>
  	<p>The <tt>envelope</tt> keyword introduces an envelope definition.</p>
  </lex>
  <lex token='EOL' pattern='\n'>
  	<p>Specifies the end of a line.</p>
  </lex>
  <lex token='EQ' pattern='='>
  	<p>Defines the variable/function definition operator.</p>
  </lex>
  <lex token='EVENT' pattern='event'>
  	<p>The <tt>event</tt> keyword introduces an event handler.</p>
  </lex>
  <lex token='FALSE' pattern='false'>
  	<p>The boolean literal <tt>false</tt>.</p>
  </lex>
  <lex token='GUARD' pattern='\|'>
  	<p>Defines the variable/function definition operator.</p>
  </lex>
  <lex token='HANDLER' pattern='handler'>
  	<p>The <tt>handler</tt> keyword introduces a callback handler.</p>
  </lex>
  <lex token='IMPLEMENTS' pattern='implements'>
  	<p>The <tt>implements</tt> keyword introduces a contract implementation in a service or card.</p>
  </lex>
  <lex token='METHOD' pattern='method'>
  	<p>The <tt>method</tt> keyword introduces a standalone method definition.</p>
  </lex>
  <lex token='NUMBER' pattern='[0-9.e+-]+'>
  	<p>A numeric literal.</p>
  </lex>
  <lex token='OBJECT' pattern='object'>
  	<p>The <tt>object</tt> keyword introduces an object declaration.</p>
  </lex>
  <lex token='OCB' pattern='\{'>
  	<p>An opening curly bracket introduces a constructor pattern match or object creation.</p>
  </lex>
  <lex token='OFFER' pattern='offer'>
  	<p>The <tt>offer</tt> keyword introduces an offer declaration.</p>
  </lex>
  <lex token='OPTIONAL' pattern='optional'>
  	<p>The <tt>optional</tt> keyword indicates that a contract method does not need to be implemented.</p>
  </lex>
  <lex token='OR' pattern='\|'>
  	<p>A token to separate cases in a union declaration.</p>
  </lex>
  <lex token='ORB' pattern='\('>
  	<p>An opening square bracket introduces a sub-element of an expression or pattern.</p>
  </lex>
  <lex token='OSB' pattern='\['>
  	<p>An opening square bracket introduces various list operations as well as polymorphic variables.</p>
  </lex>
  <lex token='PUT' pattern='&lt;-'>
  	<p>Method actions are defined using the PUT operator.</p>
  </lex>
  <lex token='SEND' pattern='&lt;-'>
  	<p>An opening square bracket introduces various list operations as well as polymorphic variables.</p>
  </lex>
  <lex token='SENDTO' pattern='=&gt;'>
  	<p>An opening square bracket introduces various list operations as well as polymorphic variables.</p>
  </lex>
  <lex token='SERVICE' pattern='service'>
  	<p>The <tt>service</tt> keyword introduces a service declaration.</p>
  </lex>
  <lex token='STATE' pattern='state'>
  	<p>The <tt>state</tt> keyword introduces a card or object state.</p>
  </lex>
  <lex token='STRING' pattern='"[^"]*"|&apos;[^&apos;]*&apos;'>
  	<p>A string literal.</p>
  </lex>
  <lex token='STRUCT' pattern='struct'>
  	<p>The <tt>struct</tt> keyword introduces a struct declaration.</p>
  </lex>
  <lex token='TEMPLATE' pattern='template'>
  	<p>The <tt>template</tt> keyword introduces a template definition.</p>
  </lex>
  <lex token='TRUE' pattern='true'>
  	<p>The boolean literal <tt>true</tt>.</p>
  </lex>
  <lex token='UNION' pattern='union'>
  	<p>The <tt>union</tt> keyword introduces a union declaration.</p>
  </lex>
  <lex token='UNOP' pattern='[\-]'>
  	<p>One of the standard unary operators.  They have precedence, but this is not apparent from the grammar.</p>
  	<p class='comment'>We should specify the precedence here.</p>
  </lex>
  <lex token='WRAPS' pattern='wraps'>
  	<p>The <tt>wraps</tt> keyword introduces a definition that wraps an entity in an envelope.</p>
  </lex>
  <lex token='event-name' pattern='[a-z][a-z0-9-]*'>
  	<p>The mnemonic name of an event, such as 'click' or 'scroll-down'.</p>
  </lex>
  <lex token='poly-var' pattern='[A-Z][A-Z]?'>
  	<p>Polymorphic variable names must be one or two capital letters.</p>
  </lex>
  <lex token='template-name' pattern='[a-z][a-z0-9-]*'>
  	<p>The name of a template or template item, which must match the name of a provided webzip element.</p>
  </lex>
  <lex token='type-name' pattern='[A-Z][A-Za-z0-9_][A-Za-z0-9_]+'>
  	<p>Concrete type names must start with a capital letter and have at
  	least three characters in the name.</p>
  </lex>
  <lex token='var-name' pattern='[a-z][A-Za-z0-9_]*'>
  	<p>Function and variable names are one or more characters, where
  	the first character must be a lower case alphabetic character.</p>
  </lex>

<!-- todo: 'file' should be an OR of flas-file, ut-file, pt-file or st-file
   - each of those should then have its own grammar
  -->  
  <production name='file'>
    <section title='Files'>
	  <description>
	    <p>FLAS units are grouped into files.  There are no specific rules about how units are grouped and grouping units together in a file offers no special privileges of access.</p>
        <p>This is the set of units that can be defined at the top level in files.  Since many of these may also be defined within nested function scopes, this is defined as a production of those together with the others that cannot.</p>
        <p>These units can only be declared at the top level in a file.</p>
        <p>Clearly the test ones are not correct yet :-)</p>
	  </description>
	</section>
    <or>
      <ref production='source-file' />
      <ref production='unit-test-file' />
      <ref production='protocol-test-file' />
      <ref production='system-test-file' />
    </or>
  </production>
  <production name='source-file'>
    <section title='Files' />
    <many>
      <ref production='top-level-unit' />
    </many>
  </production>
  <production name='unit-test-file'>
    <section title='Files' />
    <ref production='unit-test-file'/>
  </production>
  <production name='protocol-test-file'>
    <section title='Files' />
    <ref production='protocol-test-file' />
  </production>
  <production name='system-test-file'>
    <section title='Files' />
    <ref production='system-test-file' />
  </production>
  <production name='top-level-unit'>
    <section title='Files'/>
    <or>
      <ref production='top-level-definition'/>
      <ref production='function-scope-unit'/>
    </or>
  </production>
  <production name='top-level-definition'>
    <section title='Files'/>
    <or>
      <ref production='struct-declaration'/>
      <ref production='union-declaration'/>
      <ref production='entity-declaration'/>
      <ref production='deal-declaration'/>
      <ref production='offer-declaration'/>
      <ref production='envelope-declaration'/>
      <ref production='wraps-declaration'/>
      <ref production='contract-declaration'/>
      <ref production='object-declaration'/>
      <ref production='service-declaration'/>
      <ref production='card-declaration'/>
    </or>
  </production>
  <production name='function-scope'>
    <section title='Files'/>
    <many>
      <ref production='function-scope-unit' />
    </many>
  </production>
  <production name='function-scope-unit'>
    <section title='Scoping'>
	    <description>
	       This set of units can be defined at the top level in files or within the
	       scope of a function.
	    </description>
	</section>
    <producer shares='50 20 20 20'/>
    <or>
      <ref production='function-case-definition'/>
      <ref production='tuple-definition'/>
      <ref production='standalone-method-definition'/>
      <ref production='handler-definition'/>
    </or>
  </production>
  <production name='struct-declaration'>
    <section title='Data Declarations'>
	    <description>
	    </description>
	</section>
	<tested by='test.parsing.TDAStructIntroParsingTests' />
    <seq>
      <token type='STRUCT'/>
      <token type='type-name'/>
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='entity-declaration'>
    <section title='Data Declarations' />
	<tested by='test.parsing.TDAStructIntroParsingTests' />
    <seq>
      <token type='ENTITY'/>
      <token type='type-name'/>
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='deal-declaration'>
    <section title='Data Declarations' />
	<tested by='test.parsing.TDADealIntroParsingTests' />
    <seq>
      <token type='DEAL'/>
      <token type='type-name'/>
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='offer-declaration'>
    <section title='Data Declarations' />
	<tested by='test.parsing.TDAOfferIntroParsingTests' />
    <seq>
      <token type='OFFER'/>
      <token type='type-name'/>
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='struct-field-list'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <many>
      <ref production='struct-field-decl'/>
    </many>
  </production>
  <production name='struct-field-decl'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <seq>
      <ref production='type-reference'/>
      <token type='var-name'/>
      <optional>
      	<ref production='struct-initializer'/>
      </optional>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='struct-initializer'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <seq>
      <token type='SEND'/>
      <ref production='expression'/>
    </seq>
  </production>
  <production name='union-declaration'>
    <section title='Data Declarations'/>
    <seq>
      <token type='UNION'/>
      <token type='type-name'/>
      <token type='EQ'/>
      <ref production='type-reference'/>
      <many>
        <ref production='or-type-reference'/>
      </many>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='or-type-reference'>
    <section title='Data Declarations'/>
    <seq>
      <token type='OR'/>
      <ref production='type-reference'/>
    </seq>
  </production>
  <production name='envelope-declaration'>
    <section title='Envelopes'>
    	  <description>
    	    <p>Envelopes are used to provide consistent access to a range of entities.  In this way, they can be considered similar to <tt>union</tt> objects or <tt>typeclasses</tt> in Haskell.</p>
    	    <p>An envelope is defined in the same way as an entity, and all <i>instances</i> of an envelope must be <tt>entity</tt> declarations.</p>
    	    <p>The <tt>wraps</tt> definition specifies that an <tt>envelope</tt> can be represented by a specific <tt>entity</tt>.  This is then implemented by identifying how each variable in the envelope is made available from expressions which are phrased in terms of the members of the entity.</p>
    	    <p>This mapping is strictly one way.  It is not possible to <i>assign</i> to fields of an envelope.</p>
    	    <p>For more details, see <a href='index.html#envelopes'>envelopes</a>.</p>
    	  </description>
    </section>
    <seq>
      <token type='ENVELOPE'/>
      <token type='type-name'/>
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='envelope-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='envelope-field-list'>
    <section title='Envelopes'/>
    <many>
      <ref production='envelope-field-decl'/>
    </many>
  </production>
  <production name='envelope-field-decl'>
    <section title='Envelopes'/>
    <seq>
      <ref production='type-reference'/>
      <token type='var-name'/>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='wraps-declaration'>
    <section title='Envelopes' />
    <seq>
      <token type='WRAPS'/>
      <token type='type-name'/>
      <token type='SEND' />
      <token type='type-name'/>
      <indent>
        <ref production='wraps-binding-list'/>
      </indent>
    </seq>
  </production>
  <production name='wraps-binding-list'>
    <section title='Envelopes'/>
    <many>
      <ref production='wraps-binding-decl'/>
    </many>
  </production>
  <production name='wraps-binding-decl'>
    <section title='Envelopes'/>
    <seq>
      <token type='var-name'/>
      <ref production='struct-initializer'/>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='contract-declaration'>
    <section title='Contracts'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAContractIntroParsingTests' />
    <seq>
      <token type='CONTRACT'/>
      <token type='type-name'/>
      <indent>
      	<ref production='contract-method-decls'/>
      </indent>
    </seq>
  </production>
  <production name='contract-method-decls'>
    <section title='Contracts'/>
    <tested by='test.parsing.TDAContractIntroParsingTests' />
    <seq>
      <many>
      	<ref production='contract-method-decl'/>
      </many>
    </seq>
  </production>
  <production name='contract-method-decl'>
    <section title='Contracts'/>
	<tested by='test.parsing.TDAContractMethodParsingTests' />
    <seq>
      <optional>
        <token type='OPTIONAL'/>
      </optional>
      <token type='DIR'/>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern-typed'/>
      </many>
    </seq>
  </production>
  <production name='function-case-definition'>
    <section title='Functions'>
	    <description>
	       Constants and functions can be declared either at the top level or within nested scopes.
	       When declared within a nested scope, all the surrounding variables and definitions are available
	       for reference by name.
	       Note that a complete function declaration is made up of multiple cases applying to specific patterns.
	       All of the cases must be declared “together” without any intervening blocks, but this is not
	       included in this grammar specification.
	       There are two ways to declare a function case.
	       It is possible to declare a single expression on the same line as the function declaration.
	       Or the function name and argument patterns can appear on one line, and one or more guarded equations
	       can appear on subsequent lines. 
	    </description>
	</section>
    <tested by='test.parsing.TDAFunctionParsingTests' />
    <or>
      <ref production='simple-function-case-definition'/>
      <ref production='guarded-function-case-definition'/>
    </or>
  </production>
  <production name='simple-function-case-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionParsingTests' />
    <seq>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <token type='EQ'/>
      <ref production='expression'/>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-function-case-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <indent>
      	<ref production='guarded-equations'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-equations'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
      <one-or-more>
	    <ref production='guarded-expression'/>
	  </one-or-more>
	  <optional>
	    <ref production='guarded-default-expression'/>
	  </optional>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-expression'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
	    <token type='GUARD'/>
	    <ref production='expression'/>
	    <token type='EQ'/>
	    <ref production='expression'/>
    </seq>
  </production>
  <production name='guarded-default-expression'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
	    <token type='EQ'/>
	    <ref production='expression'/>
    </seq>
  </production>
  <production name='tuple-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDATupleDeclarationParsingTests' />
    <seq>
    	  <token type='ORB' />
      <token type='var-name'/>
      <many>
      	<ref production='comma-var-name' />
      </many>
    	  <token type='CRB' />
      <token type='EQ'/>
      <ref production='expression'/>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='comma-var-name'>
    <section title='Functions' />
    <tested by='test.parsing.TDATupleDeclarationParsingTests' />
    <seq>
      <token type='COMMA' />
      <token type='var-name' />
    </seq>
  </production>
  <production name='argument-pattern'>
    <section title='Patterns'>
    	  <description>
    	  </description>
    </section>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <ref production='argument-pattern-variable'/>
      <ref production='argument-pattern-list'/>
      <ref production='argument-pattern-typed'/>
      <ref production='argument-pattern-ctor'/>
    </or>
  </production>
  <production name='argument-pattern-maybe-typed'>
    <section title='Patterns' />
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <ref production='argument-pattern-variable'/>
      <ref production='argument-pattern-typed'/>
    </or>
  </production>
  <production name='argument-pattern-variable'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <token type='var-name'/>
  </production>
  <production name='argument-pattern-list'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <seq>
        <token type='OSB'/>
        <token type='CSB'/>
      </seq>
      <seq>
        <token type='OSB'/>
        <ref production='argument-pattern'/>
        <many>
          <ref production='comma-argument-pattern'/>
        </many>
        <token type='CSB'/>
      </seq>
    </or>
  </production>
  <production name='comma-argument-pattern'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='COMMA'/>
      <ref production='argument-pattern'/>
    </seq>
  </production>
  <production name='argument-pattern-typed'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='ORB'/>
      <ref production='type-reference'/>
      <token type='var-name'/>
      <token type='CRB'/>
    </seq>
  </production>
  <production name='argument-pattern-ctor'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='OCB'/>
      <token type='type-name'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <token type='CCB'/>
    </seq>
  </production>
  <production name='type-reference'>
    <section title='Types'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <seq>
        <token type='type-name'/>
        <optional>
          <ref production='poly-type-list'/>
        </optional>
      </seq>
      <seq>
        <token type='poly-var'/>
      </seq>
    </or>
  </production>
  <production name='poly-type-list'>
    <section title='Types'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='OSB'/>
      <ref production='type-reference'/>
      <many>
        <ref production='comma-type-reference'/>
      </many>
      <token type='CSB'/>
    </seq>
  </production>
  <production name='comma-type-reference'>
    <section title='Types'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='COMMA'/>
      <ref production='type-reference'/>
    </seq>
  </production>
  <production name='expression'>
    <section title='Expressions'>
      <description>
      We need to include . notation for fields, along with the fact that it has very high priority, so should probably be somewhere around the literal stage.
      But we don't particularly focus on operator precedence, so including it as a BINOP and noting that is probably fine.
      </description>
    </section>
    <tested by='test.parsing.ExprReductionTests' />
    <producer shares='50 20 5 10 5 5'/>
    <or>
      <seq>
        <ref production='literal'/>
      </seq>
      <seq>
        <token type='var-name'/>
        <many>
          <ref production='expression'/>
        </many>
      </seq>
      <seq>
        <token type='UNOP'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <ref production='expression'/>
        <token type='BINOP'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <ref production='expression'/>
        <token type='COLON'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <token type='ORB'/>
        <ref production='expression'/>
        <token type='CRB'/>
      </seq>
    </or>
  </production>
  <production name='literal'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprTokenizationTests' />
    <or>
      <token type='NUMBER' />
      <token type='STRING' />
      <token type='TRUE' />
      <token type='FALSE' />
      <ref production='list-literal'/>
      <ref production='object-literal'/>
    </or>
  </production>
  <production name='list-literal'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprReductionTests' />
    <or>
      <seq>
        <token type='OSB' />
        <token type='CSB' />
      </seq>
      <seq>
        <token type='OSB' />
        <ref production='expression' />
        <many>
          <ref production='comma-expression' />
        </many>
        <token type='CSB' />
      </seq>
    </or>
  </production>
  <production name='comma-expression'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprReductionTests' />
    <seq>
      <token type='COMMA' />
      <ref production='expression' />
    </seq>
  </production>
  <production name='object-literal'>
    <section title='Expressions' />
    <or>
      <seq>
        <token type='OCB' />
        <token type='CCB' />
      </seq>
      <seq>
        <token type='OCB' />
        <token type='var-name' />
        <token type='COLON' />
        <ref production='expression' />
        <many>
          <ref production='comma-object-member' />
        </many>
        <token type='CCB' />
      </seq>
    </or>
  </production>
  <production name='comma-object-member'>
    <section title='Expressions' />
    <seq>
      <token type='COMMA' />
      <token type='var-name' />
      <token type='COLON' />
      <ref production='expression' />
    </seq>
  </production>
  <production name='handler-definition'>
    <section title='Handler'>
      <description>
      </description>
    </section>
    <seq>
      <token type='HANDLER'/>
      <token type='type-name'/>
      <token type='type-name'/>
      <many>
      	<ref production='argument-pattern-maybe-typed' />
      </many>
      <indent>
        <ref production='method-definition'/>
      </indent>
    </seq>
  </production>
  <production name='standalone-method-definition'>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <section title='Method'>
      <description>
      Note that standalone and object methods have the same syntax, but they are sufficiently different to make it worth making it clear
      In rule ${message-method-action}, the second case is supposed to represent the user creating either a single <tt>Action</tt> object or a list of them.
      Any other <tt>expression</tt> will end up being rejected at typecheck.
      Note that the first case of the rule is not, per se, a valid expression since the service object is not in scope, but actually it will parse as one.
      </description>
    </section>
    <seq>
      <token type='METHOD'/>
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='object-method-definition'>
    <section title='Method' />
	<tested by='test.parsing.TDAObjectElementParsingTests' />
	<seq>
      <token type='METHOD'/>
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='method-definition'>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <section title='Method'/>
    <seq>
      <token type='var-name'/>
      <many>
        <ref production='argument-pattern'/>
      </many>
      <indent>
      	<ref production='method-actions'/>
      </indent>
    </seq>
  </production>
  <production name='method-actions'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
      <many>
        <ref production='method-action'/>
      </many>
      <indent>
        <ref production='function-scope-unit'/>
      </indent>
    </seq>
  </production>
  <production name='method-action'>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <section title='Method'/>
    <or>
      <ref production='message-method-action'/>
      <ref production='assign-method-action'/>
    </or>
  </production>
  <production name='message-method-action'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <or>
      <seq>
      	<token type='PUT' />
      	<ref production='service-method' />
    	    <many>
    	      <ref production='expression' />
    	    </many>
    	    <token type='EOL' />
      </seq>
      <seq>
      	<token type='PUT' />
        <ref production='expression' />
    	    <token type='EOL' />
      </seq>
    </or>
  </production>
  <production name='service-method'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <token type='var-name'/>
    	  <token type='APPLY' />
    	  <token type='var-name'/>
    </seq>
  </production>
  <production name='assign-method-action'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <ref production='member-path' />
    	  <token type='PUT' />
      <ref production='expression' />
    	  <token type='EOL' />
    </seq>
  </production>
  <production name='member-path'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <token type='var-name'/>
    	  <many>
    	    <ref production='member-path-apply'/>
    	  </many>
    </seq>
  </production>
  <production name='member-path-apply'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <token type='APPLY' />
    	  <token type='var-name'/>
    </seq>
  </production>
  <production name='object-declaration'>
    <section title='Object'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAObjectIntroParsingTests' />
    <seq>
    	  <token type='OBJECT' />
    	  <token type='type-name'/>
    	  <indent>
    	    <ref production='object-contents'/>
    	  </indent>
    </seq>
  </production>
  <production name='object-contents'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
    	  <ref production='state-declaration'/>
    	  <ref production='many-templates'/>
      <ref production='object-scope-unit'/>
    </seq>
  </production>
  <production name='state-declaration'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
    	  <token type='STATE'/>
    	  <indent>
    	    <ref production='struct-field-list'/>
    	  </indent>
    </seq>
  </production>
  <production name='object-scope-unit'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' have="1,2,3,4" />
    <producer shares='10 25 25 10 10'/>
    <or>
      <ref production='object-ctor-definition'/>
      <ref production='object-acor-definition'/>
      <ref production='object-method-definition'/>
      <ref production='function-case-definition'/>
      <ref production='handler-definition'/>
    </or>
  </production>
  <production name='object-ctor-definition'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
      <token type='CTOR' />
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='object-acor-definition'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
      <token type='ACOR' />
      <ref production='function-case-definition'/>
    </seq>
  </production>
  <production name='service-declaration'>
    <section title='Service'>
      <description>
      </description>
    </section>
    <seq>
    	  <token type='SERVICE' />
    	  <token type='type-name'/>
    	  <indent>
    	    <ref production='service-contents'/>
    	  </indent>
    </seq>
  </production>
  <production name='service-contents'>
    <section title='Service'/>
    <seq>
    	  <ref production='state-declaration'/>
      <ref production='service-scope'/>
    </seq>
  </production>
  <production name='service-scope'>
    <section title='Service'/>
    <many>
      <ref production='service-scope-unit'/>
    </many>
  </production>
  <production name='service-scope-unit'>
    <section title='Service'/>
    <or>
    	  <ref production='implements-contract'/>
      <ref production='function-scope-unit'/>
    </or>
  </production>
  <production name='card-declaration'>
    <section title='Card'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
    	  <token type='CARD' />
    	  <token type='type-name'/>
    	  <indent>
    	    <ref production='card-contents'/>
    	  </indent>
    </seq>
  </production>
  <production name='card-contents'>
    <section title='Card'/>
    <tested by='test.parsing.TDATopLevelCardParsingTests'/>
    <seq>
    	  <ref production='state-declaration'/>
      <ref production='many-templates'/>
      <ref production='card-scope'/>
    </seq>
  </production>
  <production name='card-scope'>
    <section title='Card'/>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <many>
      <ref production='card-scope-unit'/>
    </many>
  </production>
  <production name='card-scope-unit'>
    <section title='Card'/>
    <tested by='test.parsing.TDATopLevelCardParsingTests' have='1'/>
    <or>
    	  <ref production='event-handler'/>
      <ref production='service-scope-unit'/>
    </or>
  </production>
  <production name='implements-contract'>
    <section title='Implements Contract'>
      <description>
      </description>
    </section>
    <seq>
    	  <token type='IMPLEMENTS' />
    	  <token type='type-name'/>
    	  <optional>
        <token type='var-name'/>
    	  </optional>
    	  <indent>
    	    <ref production='implementation-method'/>
    	  </indent>
    </seq>
  </production>
  <production name='implementation-method'>
    <section title='Implements Contract'/>
    <seq>
      <token type='var-name'/>
      <many>
        <ref production='argument-pattern-variable'/>
      </many>
      <indent>
      	<ref production='method-actions'/>
      </indent>
    </seq>
  </production>
  <production name='event-handler'>
    <section title='Events'>
      <description>
        <p>An event handler is a special type of method on a card, which can respond to UI events.</p>
        <p>Although not part of the grammar, each event will receive an appropriate event object as its final argument.</p>
        <p>Event handlers are not called directly by the system but through the template mechanism (see some rule) and are generally curried, in that some arguments are presented as part of the configuration, and the event itself is provided by the system when called.</p>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
      <token type='EVENT'/>
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='many-templates'>
    <section title='Templates'>
      <description>
        <p>Each card can have zero or more templates.  If it has no templates, it cannot have any visual representation.</p>
        <p>If it has at least one template, the first template name must be defined as a <tt>card</tt> in an associated webzip file.  Other templates must be associated with <tt>item</tt>s in a webzip file.</p>
        <p>Each template consists of a set of binding of values to portions of the template.</p>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <many>
      <ref production='named-template-definition'/>
    </many>
  </production>
  <production name='named-template-definition'>
    <section title='Templates'/>
    <seq>
      <token type='TEMPLATE'/>
      <token type='template-name'/>
      <indent>
        <ref production='template-bind'/>
      </indent>
    </seq>
  </production>
  <production name='template-bind'>
    <section title='Template Bindings'>
      <description>
        <p>Each binding is responsible for filling one slot in the template, which can be of type <tt>punnet</tt>, <tt>container</tt> or <tt>content</tt>.</p>
        <p>The first case of rule ${one-template-bind} enables a value to be "assigned" to a slot in the template.  The exact semantics of this depend on the slot type; see <a href='index.html#connecting-elements-to-cards'>connecting elements to cards</a> for details.</p>
        <p>The second case allows the assignment to be conditional on another expression.  In this case, the conditional (first) expression of each case of rule ${option-template-bind}, which must be of type boolean, is considered and the first one to evaluate to <tt>true</tt> is selected.  The value (second) expression is then used as the value.  The rule ${default-option-template-bind} may be used to specify a default assignment if none of the previous cases match.</p>
        <p>The degenerate (third) case for rule ${one-template-bind} can only be used to customize <tt>style</tt> elements.  In this case the template name is provided and the styles and events are immediate descendants of this.</p>
        <p>For <tt>container</tt> slots <i>only</i>, it is possible to specify an <tt>item</tt> template that the value should be passed to using rule ${pass-to-template}.</p>
        <p>Styling and event handling may be added to all elements except <tt>punnet</tt>s, which hand off styling and event handling to their contained cards.  In general, this will also not be used with <tt>container</tt> slots.</p>
      </description>
    </section>
    <seq>
      <ref production='one-template-bind'/>
      <indent>
        <ref production='template-customization'/>
      </indent>
    </seq>
  </production>
  <production name='one-template-bind'>
    <section title='Template Bindings'/>
    <or>
      <seq>
	    <token type='template-name'/>
	    <token type='SEND'/>
	    <ref production='expression'/>
	    <optional>
	    	  <ref production='pass-to-template' />
	    </optional>
	  </seq>
      <seq>
	    <token type='template-name'/>
        <indent>
          <ref production='option-template-binds'/>
        </indent>
	  </seq>
      <seq>
	    <token type='template-name'/>
	  </seq>
    </or>
  </production>
  <production name='option-template-binds'>
    <section title='Template Bindings'/>
    <seq>
      <many>
        <ref production='option-template-bind'/>
      </many>
      <optional>
        <ref production='default-option-template-bind'/>
      </optional>
    </seq>
  </production>
  <production name='option-template-bind'>
    <section title='Template Bindings'/>
    <seq>
      <token type='OR'/>
	  <ref production='expression'/>
	  <token type='SEND'/>
	  <ref production='expression'/>
	  <optional>
	  	  <ref production='pass-to-template' />
	  </optional>
	</seq>
  </production>
  <production name='default-option-template-bind'>
    <section title='Template Bindings'/>
    <seq>
	  <token type='OR'/>
	  <token type='SEND'/>
	  <ref production='expression'/>
	  <optional>
	    <ref production='pass-to-template' />
	  </optional>
	</seq>
  </production>
  <production name='pass-to-template'>
    <section title='Template Bindings'/>
    <seq>
      <token type='SENDTO'/>
      <token type='template-name'/>
    </seq>
  </production>
  <production name='template-customization'>
    <section title='Template Bindings'/>
    <or>
      <ref production="template-style"/>
      <ref production="template-event"/>
    </or>
  </production>
  <production name='template-style'>
    <section title='Template Customization'>
    		<description>
    			<p>For <tt>content</tt> and <tt>style</tt> elements, it is possible to <i>customize</i> the element by applying styling and adding event handlers.</p>
    			<p>Rule ${template-style} defines the behaviour for styling.  Any number of styling rules may be applied; each will match the <tt>expr</tt> and, if true, will add the classes identified by the strings to the element's class list.</p>
    			<p>Rule ${template-event} defines event handlers.  Each of the predefined events can be mapped exactly once per element.  The outcome will be the invocation of an event handler defined on the card as <tt>var-name</tt>.  It will receive a set of arguments along with an event object of a type appropriate for the named event.</p>
    		</description>
    </section>
    <seq>
      <token type='OR'/>
      <ref production='expression'/>
      <token type='SENDTO' />
      <one-or-more>
      	<token type='STRING'/>
      </one-or-more>
    </seq>
  </production>
  <production name='template-event'>
    <section title='Template Customization' />
    <seq>
      <token type='event-name' />
      <token type='SENDTO'/>
      <token type='var-name'/>
      <many>
      	<ref production='expression' />
      </many>
    </seq>
  </production>
</grammar>