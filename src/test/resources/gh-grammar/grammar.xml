<grammar>
  <lex token='APPLY' pattern='\.'>
  	<p>The apply operator.</p>
  </lex>
  <lex token='BINOP' pattern='[-+*/.]'>
  	<p>One of the standard binary operators.  They have precedence, but this is not apparent from the grammar.</p>
  	<p class='comment'>We should specify the precedence here.</p>
  </lex>
  <lex token='CARD' pattern='card'>
  	<p>The <tt>card</tt> keyword introduces a card definition.</p>
  </lex>
  <lex token='CCB' pattern='\}'>
  	<p>A closing curly bracket delimits the end of an constructor pattern or object creation.</p>
  </lex>
  <lex token='COMMA' pattern=','>
  	<p>Separates similar items in a list.</p>
  </lex>
  <lex token='CONTRACT' pattern='contract'>
  	<p>The <tt>contract</tt> keyword introduces a contract declaration.</p>
  </lex>
  <lex token='CRB' pattern='\)'>
  	<p>A closing round bracket delimits the end of an expression or pattern.</p>
  </lex>
  <lex token='CSB' pattern='\]'>
  	<p>A closing square bracket delimits the end of a list operation or polymorphic variable list.</p>
  </lex>
  <lex token='DIR' pattern='up|down'>
  	<p>The <tt>up</tt> and <tt>down</tt> keywords indicate the sense in which a contract method is called.</p>
  </lex>
  <lex token='EOL' pattern='\n'>
  	<p>Specifies the end of a line.</p>
  </lex>
  <lex token='EQ' pattern='='>
  	<p>Defines the variable/function definition operator.</p>
  </lex>
  <lex token='GUARD' pattern='|'>
  	<p>Defines the variable/function definition operator.</p>
  </lex>
  <lex token='HANDLER' pattern='handler'>
  	<p>The <tt>handler</tt> keyword introduces a handler definition.</p>
  </lex>
  <lex token='METHOD' pattern='method'>
  	<p>The <tt>method</tt> keyword introduces a standalone method definition.</p>
  </lex>
  <lex token='OBJECT' pattern='object'>
  	<p>The <tt>object</tt> keyword introduces an object declaration.</p>
  </lex>
  <lex token='OCB' pattern='\{'>
  	<p>An opening curly bracket introduces a constructor pattern match or object creation.</p>
  </lex>
  <lex token='OPTIONAL' pattern='optional'>
  	<p>The <tt>optional</tt> keyword indicates that a contract method does not need to be implemented.</p>
  </lex>
  <lex token='OR' pattern='|'>
  	<p>A token to separate cases in a union declaration.</p>
  </lex>
  <lex token='ORB' pattern='\('>
  	<p>An opening square bracket introduces a sub-element of an expression or pattern.</p>
  </lex>
  <lex token='OSB' pattern='\['>
  	<p>An opening square bracket introduces various list operations as well as polymorphic variables.</p>
  </lex>
  <lex token='PUT' pattern='&lt;-'>
  	<p>Method actions are defined using the PUT operator.</p>
  </lex>
  <lex token='SEND' pattern='&lt;-'>
  	<p>An opening square bracket introduces various list operations as well as polymorphic variables.</p>
  </lex>
  <lex token='STATE' pattern='state'>
  	<p>The <tt>state</tt> keyword introduces a card or object state.</p>
  </lex>
  <lex token='STRUCT' pattern='struct'>
  	<p>The <tt>struct</tt> keyword introduces a struct declaration.</p>
  </lex>
  <lex token='TEMPLATE' pattern='template'>
  	<p>The <tt>template</tt> keyword introduces a template definition.</p>
  </lex>
  <lex token='UNION' pattern='union'>
  	<p>The <tt>union</tt> keyword introduces a union declaration.</p>
  </lex>
  <lex token='UNOP' pattern='[\-]'>
  	<p>One of the standard unary operators.  They have precedence, but this is not apparent from the grammar.</p>
  	<p class='comment'>We should specify the precedence here.</p>
  </lex>
  <lex token='poly-var' pattern='[A-Z][A-Z]?'>
  	<p>Polymorphic variable names must be one or two capital letters.</p>
  </lex>
  <lex token='type-name' pattern='[A-Z][A-Za-z0-9_][A-Za-z0-9_]+'>
  	<p>Concrete type names must start with a capital letter and have at
  	least three characters in the name.</p>
  </lex>
  <lex token='var-name' pattern='[a-z][A-Za-z0-9_]*'>
  	<p>Function and variable names are one or more characters, where
  	the first character must be a lower case alphabetic character.</p>
  </lex>
  
  <production name='file'>
    <section title='Files'>
    <!-- In a description, ${file} should turn into (1) so that you can say
         "in rule ${file}" and have "in rule (1)" come out.
      -->
	    <description>
	    <p>
	        FLAS units are grouped into files.
	        There are no specific rules about how units are grouped and grouping
	        units together in a file offers no special privileges of access.
</p>
<p>
       This is the set of units that can be defined at the top level in files.
       Since many of these may also be defined within nested function scopes,
       this is defined as a production of those together with the others that cannot.
</p>
<p>
       These units can only be declared at the top level in a file.
</p>
	    </description>
	</section>
    <many>
      <ref production='top-level-unit' />
    </many>
  </production>
  <production name='top-level-unit'>
    <section title='Files'/>
    <or>
      <ref production='top-level-definition'/>
      <ref production='function-scope-unit'/>
    </or>
  </production>
  <production name='top-level-definition'>
    <section title='Files'/>
    <or>
      <ref production='struct-declaration'/>
      <ref production='union-declaration'/>
      <ref production='contract-declaration'/>
      <ref production='object-declaration'/>
      <ref production='card-declaration'/>
    </or>
  </production>
  <production name='function-scope'>
    <section title='Files'/>
    <many>
      <ref production='function-scope-unit' />
    </many>
  </production>
  <production name='function-scope-unit'>
    <section title='Scoping'>
	    <description>
	       This set of units can be defined at the top level in files or within the
	       scope of a function.
	    </description>
	</section>
    <or>
      <ref production='function-case-definition'/>
      <ref production='standalone-method-definition'/>
      <ref production='handler-definition'/>
    </or>
  </production>
  <production name='struct-declaration'>
    <section title='Data Declarations'>
	    <description>
	    </description>
	</section>
    <seq>
      <token type='STRUCT'/>
      <token type='type-name'/>
      <optional>
        <ref production='poly-var-list'/>
      </optional>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='poly-var-list'>
    <section title='Data Declarations'/>
    <seq>
      <token type='OSB'/>
      <token type='poly-var'/>
      <many>
        <ref production='comma-poly-var'/>
      </many>
      <token type='CSB'/>
    </seq>
  </production>
  <production name='comma-poly-var'>
    <section title='Data Declarations'/>
    <seq>
      <token type='COMMA'/>
      <token type='poly-var'/>
    </seq>
  </production>
  <production name='struct-field-list'>
    <section title='Data Declarations'/>
    <many>
      <ref production='struct-field-decl'/>
    </many>
  </production>
  <production name='struct-field-decl'>
    <section title='Data Declarations'/>
    <seq>
      <ref production='type-reference'/>
      <token type='var-name'/>
      <optional>
      	<ref production='struct-initializer'/>
      </optional>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='struct-initializer'>
    <section title='Data Declarations'/>
    <seq>
      <token type='SEND'/>
      <ref production='expression'/>
    </seq>
  </production>
  <production name='union-declaration'>
    <section title='Data Declarations'/>
    <seq>
      <token type='UNION'/>
      <token type='type-name'/>
      <token type='EQ'/>
      <ref production='type-reference'/>
      <many>
        <ref production='or-type-reference'/>
      </many>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='or-type-reference'>
    <section title='Data Declarations'/>
    <seq>
      <token type='OR'/>
      <ref production='type-reference'/>
    </seq>
  </production>
  <production name='contract-declaration'>
    <section title='Contracts'>
      <description>
      </description>
    </section>
    <seq>
      <token type='CONTRACT'/>
      <token type='type-name'/>
      <indent>
      	<ref production='contract-method-decls'/>
      </indent>
    </seq>
  </production>
  <production name='contract-method-decls'>
    <section title='Contracts'/>
    <seq>
      <many>
      	<ref production='contract-method-decl'/>
      </many>
    </seq>
  </production>
  <production name='contract-method-decl'>
    <section title='Contracts'/>
    <seq>
      <optional>
        <token type='OPTIONAL'/>
      </optional>
      <token type='DIR'/>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern-typed'/>
      </many>
    </seq>
  </production>
  <production name='function-case-definition'>
    <section title='Functions'>
	    <description>
	       Constants and functions can be declared either at the top level or within nested scopes.
	       When declared within a nested scope, all the surrounding variables and definitions are available
	       for reference by name.
	       Note that a complete function declaration is made up of multiple cases applying to specific patterns.
	       All of the cases must be declared “together” without any intervening blocks, but this is not
	       included in this grammar specification.
	       There are two ways to declare a function case.
	       It is possible to declare a single expression on the same line as the function declaration.
	       Or the function name and argument patterns can appear on one line, and one or more guarded equations
	       can appear on subsequent lines. 
	    </description>
	</section>
    <or>
      <ref production='simple-function-case-definition'/>
      <ref production='guarded-function-case-definition'/>
    </or>
  </production>
  <production name='simple-function-case-definition'>
    <section title='Functions'/>
    <seq>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <token type='EQ'/>
      <ref production='expression'/>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-function-case-definition'>
    <section title='Functions'/>
    <seq>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <indent>
      	<ref production='guarded-equations'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-equations'>
    <section title='Functions'/>
    <seq>
      <many>
	    <ref production='guarded-expression'/>
	  </many>
	  <optional>
	    <ref production='guarded-default-expression'/>
	  </optional>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-expression'>
    <section title='Functions'/>
    <seq>
	    <token type='GUARD'/>
	    <ref production='expression'/>
	    <token type='EQ'/>
	    <ref production='expression'/>
    </seq>
  </production>
  <production name='guarded-default-expression'>
    <section title='Functions'/>
    <seq>
	    <token type='EQ'/>
	    <ref production='expression'/>
    </seq>
  </production>
  <production name='argument-pattern'>
    <section title='Patterns'>
    	  <description>
    	  </description>
    </section>
    <or>
      <ref production='argument-pattern-variable'/>
      <ref production='argument-pattern-list'/>
      <ref production='argument-pattern-typed'/>
      <ref production='argument-pattern-ctor'/>
    </or>
  </production>
  <production name='argument-pattern-maybe-typed'>
    <section title='Patterns'>
    	  <description>
    	  </description>
    </section>
    <or>
      <ref production='argument-pattern-variable'/>
      <ref production='argument-pattern-typed'/>
    </or>
  </production>
  <production name='argument-pattern-variable'>
    <section title='Patterns'/>
    <token type='var-name'/>
  </production>
  <production name='argument-pattern-list'>
    <section title='Patterns'/>
    <or>
      <seq>
        <token type='OSB'/>
        <token type='CSB'/>
      </seq>
      <seq>
        <token type='OSB'/>
        <ref production='argument-pattern'/>
        <many>
          <ref production='comma-argument-pattern'/>
        </many>
        <token type='CSB'/>
      </seq>
    </or>
  </production>
  <production name='comma-argument-pattern'>
    <section title='Patterns'/>
    <seq>
      <token type='COMMA'/>
      <ref production='argument-pattern'/>
    </seq>
  </production>
  <production name='argument-pattern-typed'>
    <section title='Patterns'/>
    <seq>
      <token type='ORB'/>
      <ref production='type-reference'/>
      <token type='var-name'/>
      <token type='CRB'/>
    </seq>
  </production>
  <production name='argument-pattern-ctor'>
    <section title='Patterns'/>
    <seq>
      <token type='OCB'/>
      <token type='type-name'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <token type='CCB'/>
    </seq>
  </production>
  <production name='type-reference'>
    <section title='Types'>
      <description>
      </description>
    </section>
    <or>
      <seq>
        <token type='type-name'/>
        <optional>
          <ref production='poly-type-list'/>
        </optional>
      </seq>
      <seq>
        <token type='poly-var'/>
      </seq>
    </or>
  </production>
  <production name='poly-type-list'>
    <section title='Types'/>
    <seq>
      <token type='OSB'/>
      <ref production='type-reference'/>
      <many>
        <ref production='comma-type-reference'/>
      </many>
      <token type='CSB'/>
    </seq>
  </production>
  <production name='comma-type-reference'>
    <section title='Types'/>
    <seq>
      <token type='COMMA'/>
      <ref production='type-reference'/>
    </seq>
  </production>
  <production name='expression'>
    <section title='Expressions'>
      <description>
      </description>
    </section>
    <or>
      <seq>
        <token type='var-name'/>
        <many>
          <ref production='expression'/>
        </many>
      </seq>
      <seq>
        <token type='UNOP'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <ref production='expression'/>
        <token type='BINOP'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <token type='ORB'/>
        <ref production='expression'/>
        <token type='CRB'/>
      </seq>
      <!-- also list & object creators [], {} -->
    </or>
  </production>
  <production name='handler-definition'>
    <section title='Handler'>
      <description>
      </description>
    </section>
    <seq>
      <token type='HANDLER'/>
      <token type='type-name'/>
      <token type='type-name'/>
      <many>
      	<ref production='argument-pattern-maybe-typed' />
      </many>
      <indent>
        <ref production='method-definition'/>
      </indent>
    </seq>
  </production>
  <production name='standalone-method-definition'>
    <section title='Method'>
      <description>
      </description>
    </section>
    <seq>
      <token type='METHOD'/>
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='method-definition'>
    <section title='Method'/>
    <seq>
      <token type='var-name'/>
      <many>
        <ref production='argument-pattern'/>
      </many>
      <indent>
      	<ref production='method-actions'/>
      </indent>
    </seq>
  </production>
  <production name='method-actions'>
    <section title='Method'/>
    <seq>
      <many>
        <ref production='method-action'/>
      </many>
      <indent>
        <ref production='function-scope-unit'/>
      </indent>
    </seq>
  </production>
  <production name='method-action'>
    <section title='Method'/>
    <or>
      <ref production='message-method-action'/>
      <ref production='assign-method-action'/>
    </or>
  </production>
  <production name='message-method-action'>
    <section title='Method'/>
    <seq>
    	  <token type='PUT' />
    	  <ref production='service-method' />
    	  <many>
    	    <ref production='expression' />
    	  </many>
    	  <token type='EOL' />
    </seq>
  </production>
  <production name='service-method'>
    <section title='Method'/>
    <seq>
    	  <token type='var-name'/>
    	  <token type='APPLY' />
    	  <token type='var-name'/>
    </seq>
  </production>
  <production name='assign-method-action'>
    <section title='Method'/>
    <seq>
    	  <ref production='member-path' />
    	  <token type='PUT' />
      <ref production='expression' />
    	  <token type='EOL' />
    </seq>
  </production>
  <production name='member-path'>
    <section title='Method'/>
    <seq>
    	  <token type='var-name'/>
    	  <many>
    	    <ref production='member-path-apply'/>
    	  </many>
    </seq>
  </production>
  <production name='member-path-apply'>
    <section title='Method'/>
    <seq>
    	  <token type='APPLY' />
    	  <token type='var-name'/>
    </seq>
  </production>
  <production name='object-declaration'>
    <section title='Object'>
      <description>
      </description>
    </section>
    <seq>
    	  <token type='OBJECT' />
    	  <token type='type-name'/>
    	  <indent>
    	    <ref production='object-contents'/>
    	  </indent>
    </seq>
  </production>
  <production name='object-contents'>
    <section title='Object'/>
    <seq>
    	  <ref production='state-declaration'/>
    	  <ref production='default-or-many-templates'/>
      <ref production='function-scope-unit'/>
    </seq>
  </production>
  <production name='state-declaration'>
    <section title='Object'/>
    <seq>
    	  <token type='STATE'/>
    	  <indent>
    	    <ref production='struct-field-list'/>
    	  </indent>
    </seq>
  </production>
  <production name='default-or-many-templates'>
    <section title='Object'/>
    <or>
      <ref production='default-template-definition'/>
      <many>
        <ref production='named-template-definition'/>
      </many>
    </or>
  </production>
  <production name='default-template-definition'>
    <section title='Object'/>
    <seq>
      <token type='TEMPLATE'/>
      <indent>
        <ref production='template-action'/>
      </indent>
    </seq>
  </production>
  <production name='named-template-definition'>
    <section title='Object'/>
    <seq>
      <token type='TEMPLATE'/>
      <token type='var-name'/>
      <indent>
        <ref production='template-action'/>
      </indent>
    </seq>
  </production>
  <production name='card-declaration'>
    <section title='Card'>
      <description>
      </description>
    </section>
    <seq>
    	  <token type='CARD' />
    	  <token type='type-name'/>
    	  <indent>
    	    <ref production='card-contents'/>
    	  </indent>
    </seq>
  </production>
  <production name='card-contents'>
    <section title='Card'/>
    <seq>
    	  <ref production='state-declaration'/>
    	  <optional>
        <ref production='default-template-definition'/>
    	  </optional>
      <many>
        <ref production='named-template-definition'/>
      </many>
      <ref production='card-scope-unit'/>
    </seq>
  </production>
  <!--
  contract-impl[2 types]
  event*
  function-scope-unit
  -->
</grammar>
