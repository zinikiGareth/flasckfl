<grammar title='FLAS Grammar'>
  <css href='grammar.css' />
  <burble name='preamble'>
    <p>FLAS is an actor-based functional language for cards.</p>
  </burble>
  <burble name='lex'>
    <h2>Lexical Issues</h2>
  </burble>
  <lex token='ACOR' pattern='acor'>
  	<p>The <tt>acor</tt> keyword introduces an object accessor function.</p>
  </lex>
  <lex token='APPLY' pattern='\.'>
  	<p>The apply operator.</p>
  </lex>
  <lex token='ASSERT' pattern='assert'>
  	<p>The <tt>assert</tt> keyword introduces an assert step in a unit test.</p>
  </lex>
  <lex token='BINOP' pattern='[-+*/.]'>
  	<p>One of the standard binary operators.  They have precedence, but this is not apparent from the grammar.</p>
  	<p class='comment'>We should specify the precedence here.</p>
  </lex>
  <lex token='CARD' pattern='card'>
  	<p>The <tt>card</tt> keyword introduces a card definition.</p>
  </lex>
  <lex token='CCB' pattern='\}'>
  	<p>A closing curly bracket delimits the end of a constructor pattern or object creation.</p>
  </lex>
  <lex token='COLON' pattern=':'>
  	<p>Can be an operator or can be used to define object literals.</p>
  </lex>
  <lex token='COMMA' pattern=','>
  	<p>Separates similar items in a list.</p>
  </lex>
  <lex token='CONTRACT' pattern='contract'>
  	<p>The <tt>contract</tt> keyword introduces a contract declaration.</p>
  	<p>It is also used in unit tests to invoke a contract method on a card or service.</p>
  </lex>
  <lex token='CRB' pattern='\)'>
  	<p>A closing round bracket delimits the end of an expression or pattern.</p>
  </lex>
  <lex token='CSB' pattern='\]'>
  	<p>A closing square bracket delimits the end of a list operation or polymorphic variable list.</p>
  </lex>
  <lex token='CTOR' pattern='ctor'>
  	<p>The <tt>ctor</tt> keyword introduces an object constructor declaration.</p>
  </lex>
  <lex token='DATA' pattern='data'>
  	<p>The <tt>data</tt> keyword introduces a data declaration in a unit test.</p>
  </lex>
  <lex token='DEAL' pattern='deal'>
  	<p>The <tt>deal</tt> keyword introduces a deal declaration.</p>
  </lex>
  <lex token='DOCWORD' pattern='[a-zA-Z_0-9]+'>
    <p>Words that can appear in the documentation of a test case.</p>
  </lex>
  <lex token='ENTITY' pattern='entity'>
  	<p>The <tt>entity</tt> keyword introduces an entity definition.</p>
  </lex>
  <lex token='ENVELOPE' pattern='envelope'>
  	<p>The <tt>envelope</tt> keyword introduces an envelope definition.</p>
  </lex>
  <lex token='EOL' pattern='\n'>
  	<p>Specifies the end of a line.</p>
  </lex>
  <lex token='EQ' pattern='='>
  	<p>Defines the variable/function definition operator.</p>
  </lex>
  <lex token='EVENT' pattern='event'>
  	<p>The <tt>event</tt> keyword introduces an event handler.</p>
  </lex>
  <lex token='EXPECT' pattern='expect'>
  	<p>The <tt>expect</tt> keyword introduces a mock expectation.</p>
  </lex>
  <lex token='FALSE' pattern='false'>
  	<p>The boolean literal <tt>false</tt>.</p>
  </lex>
  <lex token='GUARD' pattern='\|'>
  	<p>Defines the variable/function definition operator.</p>
  </lex>
  <lex token='HANDLE' pattern='-&gt;'>
  	<p>The HANDLE operator is used to assign subscription handles to handle variables.</p>
  </lex>
  <lex token='HANDLER' pattern='handler'>
  	<p>The <tt>handler</tt> keyword introduces a callback handler.</p>
  </lex>
  <lex token='IMPLEMENTS' pattern='implements'>
  	<p>The <tt>implements</tt> keyword introduces a contract implementation in a card.</p>
  </lex>
  <lex token='INVOKE' pattern='invoke'>
  	<p>The <tt>invoke</tt> keyword is used in unit tests to invoke a method on an object.</p>
  </lex>
  <lex token='METHOD' pattern='method'>
  	<p>The <tt>method</tt> keyword introduces a standalone method definition.</p>
  </lex>
  <lex token='NUMBER' pattern='[0-9.e+-]+'>
  	<p>A numeric literal.</p>
  </lex>
  <lex token='OBJECT' pattern='object'>
  	<p>The <tt>object</tt> keyword introduces an object declaration.</p>
  </lex>
  <lex token='OCB' pattern='\{'>
  	<p>An opening curly bracket introduces a constructor pattern match or object creation.</p>
  </lex>
  <lex token='OFFER' pattern='offer'>
  	<p>The <tt>offer</tt> keyword introduces an offer declaration.</p>
  </lex>
  <lex token='OPTIONAL' pattern='optional'>
  	<p>The <tt>optional</tt> keyword indicates that a contract method does not need to be implemented.</p>
  </lex>
  <lex token='ORB' pattern='\('>
  	<p>An opening square bracket introduces a sub-element of an expression or pattern.</p>
  </lex>
  <lex token='OSB' pattern='\['>
  	<p>An opening square bracket introduces various list operations as well as polymorphic variables.</p>
  </lex>
  <lex token='PROVIDES' pattern='provides'>
  	<p>The <tt>provides</tt> keyword introduces a block indicating that the service portion of a contract will be provided.</p>
  </lex>
  <lex token='REQUIRES' pattern='requires'>
  	<p>The <tt>requires</tt> keyword identifies a variable which is bound to a service of the specified contract.</p>
  </lex>
  <lex token='SEND' pattern='&lt;-'>
  	<p>Method actions, variable assignments and template definitions are defined using the SEND operator.</p>
  </lex>
  <lex token='SENDTO' pattern='=&gt;'>
  	<p>The SENDTO operator is used to pass things around in templates.</p>
  </lex>
  <lex token='SERVICE' pattern='service'>
  	<p>The <tt>service</tt> keyword introduces a service declaration.</p>
  </lex>
  <lex token='STATE' pattern='state'>
  	<p>The <tt>state</tt> keyword introduces a card or object state.</p>
  </lex>
  <lex token='STRING' pattern='"[^"]*"|&apos;[^&apos;]*&apos;'>
  	<p>A string literal.</p>
  </lex>
  <lex token='STRUCT' pattern='struct'>
  	<p>The <tt>struct</tt> keyword introduces a struct declaration.</p>
  </lex>
  <lex token='TEMPLATE' pattern='template'>
  	<p>The <tt>template</tt> keyword introduces a template definition.</p>
  </lex>
  <lex token='TEST' pattern='test'>
  	<p>The <tt>test</tt> keyword introduces a unit test case.</p>
  </lex>
  <lex token='TRUE' pattern='true'>
  	<p>The boolean literal <tt>true</tt>.</p>
  </lex>
  <lex token='UNION' pattern='union'>
  	<p>The <tt>union</tt> keyword introduces a union declaration.</p>
  </lex>
  <lex token='UNOP' pattern='[\-]'>
  	<p>One of the standard unary operators.  They have precedence, but this is not apparent from the grammar.</p>
  	<p class='comment'>We should specify the precedence here.</p>
  </lex>
  <lex token='WRAPS' pattern='wraps'>
  	<p>The <tt>wraps</tt> keyword introduces a definition that wraps an entity in an envelope.</p>
  </lex>
  <lex token='event-name' pattern='[a-z][a-z0-9-]*'>
  	<p>The mnemonic name of an event, such as 'click' or 'scroll-down'.</p>
  </lex>
  <lex token='poly-var' pattern='[A-Z][A-Z]?'>
  	<p>Polymorphic variable names must be one or two capital letters.</p>
  </lex>
  <lex token='template-name' pattern='[a-z][a-z0-9-]*'>
  	<p>The name of a template or template item, which must match the name of a provided webzip element.</p>
  </lex>
  <lex token='type-name' pattern='[A-Z][A-Za-z0-9_][A-Za-z0-9_]+'>
  	<p>Concrete type names must start with a capital letter and have at
  	least three characters in the name.</p>
  </lex>
  <lex token='var-name' pattern='[a-z][A-Za-z0-9_]*'>
  	<p>Function and variable names are one or more characters, where
  	the first character must be a lower case alphabetic character.</p>
  </lex>

<!-- todo: 'file' should be an OR of flas-file, ut-file, pt-file or st-file
   - each of those should then have its own grammar
  -->  
  <production name='file'>
    <section title='Files'>
	  <description>
	    <p>FLAS units are grouped into files.  There are no specific rules about how units are grouped and grouping units together in a file offers no special privileges of access.</p>
        <p>This is the set of units that can be defined at the top level in files.  Since many of these may also be defined within nested function scopes, this is defined as a production of those together with the others that cannot.</p>
        <p>These units can only be declared at the top level in a file.</p>
        <p>Clearly the test ones are not correct yet :-)</p>
	  </description>
	</section>
    <or>
      <ref production='source-file' />
      <ref production='unit-test-file' />
      <ref production='protocol-test-file' />
      <ref production='system-test-file' />
    </or>
  </production>
  <production name='source-file'>
    <section title='Files' />
	<tested by='test.parsing.' /> <!-- spread over many -->
    <many>
      <ref production='top-level-unit' />
    </many>
  </production>
  <production name='unit-test-file'>
    <section title='Files' />
	<tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <seq>
    	  <push-part filename='true'/>
      <many>
        <ref production='unit-test-unit' />
      </many>
    </seq>
  </production>
  <production name='protocol-test-file'>
    <section title='Files' />
    <many>
      <ref production='protocol-test-unit' />
    </many>
  </production>
  <production name='system-test-file'>
    <section title='Files' />
    <many>
      <ref production='system-test-unit' />
    </many>
  </production>
  <production name='top-level-unit'>
    <section title='Files'/>
	<tested by='test.parsing.' /> <!-- spread over many -->
    <or>
      <ref production='top-level-definition'/>
      <ref production='function-scope-unit'/>
    </or>
  </production>
  <production name='top-level-definition'>
    <section title='Files'/>
	<tested by='test.parsing.'/> <!-- spread over many -->
    <or>
      <ref production='struct-declaration'/>
      <ref production='union-declaration'/>
      <ref production='entity-declaration'/>
      <ref production='deal-declaration'/>
      <ref production='offer-declaration'/>
      <ref production='envelope-declaration'/>
      <ref production='wraps-declaration'/>
      <ref production='contract-declaration'/>
      <ref production='object-declaration'/>
      <ref production='service-declaration'/>
      <ref production='card-declaration'/>
    </or>
  </production>
  <production name='function-scope'>
    <section title='Files'/>
	<tested by='test.parsing.' /> <!-- spread over many -->
    <many>
      <ref production='function-scope-unit' />
    </many>
  </production>
  <production name='function-scope-unit'>
    <section title='Scoping'>
	    <description>
	       This set of units can be defined at the top level in files or within the
	       scope of a function.
	    </description>
	</section>
	<tested by='test.parsing.' /> <!-- spread over many -->
    <producer shares='50 20 20 20'/>
    <or>
      <ref production='function-case-definition'/>
      <ref production='tuple-definition'/>
      <ref production='standalone-method-definition'/>
      <ref production='handler-definition'/>
    </or>
  </production>
  <production name='struct-declaration'>
    <section title='Data Declarations'>
	    <description>
	    </description>
	</section>
	<tested by='test.parsing.TDAStructIntroParsingTests' />
    <seq>
      <token type='STRUCT'/>
    	  <token type='type-name' names='STRUCT\[${name}.*\]' />
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='entity-declaration'>
    <section title='Data Declarations' />
	<tested by='test.parsing.TDAStructIntroParsingTests' />
    <seq>
      <token type='ENTITY'/>
    	  <token type='type-name' names='ENTITY\[${name}.*\]' />
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='deal-declaration'>
    <section title='Data Declarations' />
	<tested by='test.parsing.TDADealIntroParsingTests' />
    <seq>
      <token type='DEAL'/>
    	  <token type='type-name' names='DEAL\[${name}.*\]' />
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='offer-declaration'>
    <section title='Data Declarations' />
	<tested by='test.parsing.TDAOfferIntroParsingTests' />
    <seq>
      <token type='OFFER'/>
    	  <token type='type-name' names='OFFER\[${name}.*\]' />
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='struct-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='struct-field-list'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <many>
      <ref production='struct-field-decl'/>
    </many>
  </production>
  <production name='struct-field-decl'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <seq>
      <ref production='type-reference'/>
      <token type='var-name' names='StructField\[${name}\]'/>
      <optional>
      	<ref production='struct-initializer'/>
      </optional>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='struct-initializer'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <seq>
      <token type='SEND'/>
      <ref production='expression'/>
    </seq>
  </production>
  <production name='union-declaration'>
    <section title='Data Declarations'/>
	<tested by='test.parsing.TDAUnionParsingTests' />
    <seq>
      <token type='UNION'/>
      <token type='type-name' names='Union\[${name}\]'/>
      <indent-non-zero>
        <ref production='type-reference'/>
      </indent-non-zero>
    </seq>
  </production>
  <production name='envelope-declaration'>
    <section title='Envelopes'>
    	  <description>
    	    <p>Envelopes are used to provide consistent access to a range of entities.  In this way, they can be considered similar to <tt>union</tt> objects or <tt>typeclasses</tt> in Haskell.</p>
    	    <p>An envelope is defined in the same way as an entity, and all <i>instances</i> of an envelope must be <tt>entity</tt> declarations.</p>
    	    <p>The <tt>wraps</tt> definition specifies that an <tt>envelope</tt> can be represented by a specific <tt>entity</tt>.  This is then implemented by identifying how each variable in the envelope is made available from expressions which are phrased in terms of the members of the entity.</p>
    	    <p>This mapping is strictly one way.  It is not possible to <i>assign</i> to fields of an envelope.</p>
    	    <p>For more details, see <a href='index.html#envelopes'>envelopes</a>.</p>
    	  </description>
    </section>
	<tested by='test.parsing.TDAStructIntroParsingTests' />
    <seq>
      <token type='ENVELOPE'/>
      <token type='type-name' names='ENVELOPE\[${name}.*\]'/>
      <many>
        <token type='poly-var'/>
      </many>
      <indent>
        <ref production='envelope-field-list'/>
      </indent>
    </seq>
  </production>
  <production name='envelope-field-list'>
    <section title='Envelopes'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <many>
      <ref production='envelope-field-decl'/>
    </many>
  </production>
  <production name='envelope-field-decl'>
    <section title='Envelopes'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <seq>
      <ref production='type-reference'/>
      <token type='var-name' names='Field\[.* ${final} .*\]'/>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='wraps-declaration'>
    <section title='Envelopes' />
	<tested by='test.parsing.TDAStructIntroParsingTests' />
    <seq>
      <token type='WRAPS'/>
      <token type='type-name' names='WRAPS\[${name}.*\]'/>
      <token type='SEND' />
      <token type='type-name'/>
      <indent>
        <ref production='wraps-binding-list'/>
      </indent>
    </seq>
  </production>
  <production name='wraps-binding-list'>
    <section title='Envelopes'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <many>
      <ref production='wraps-binding-decl'/>
    </many>
  </production>
  <production name='wraps-binding-decl'>
    <section title='Envelopes'/>
	<tested by='test.parsing.TDAStructFieldParsingTests' />
    <seq>
      <token type='var-name' names='Field\[${final}.*\]'/>
      <ref production='struct-initializer'/>
      <token type='EOL'/>
    </seq>
  </production>
  <production name='contract-declaration'>
    <section title='Contracts'>
      <description>
        Contracts are core to FLAS.
        A contract defines an abstraction of what a card, agent or service does in a way that should be independently testable with tests written against the abstraction.
        <p>
        There are three types of contracts:
        </p>
        <ul>
        <li>those that are implemented by cards and agents and can be called by the container;</li>
        <li>those provided by a service or a providing agent and can be required by cards and then called;</li>
        <li>those defining how handlers will operate.</li>
        </ul>
        In each case, the contract specifies a set of methods which must all be implemented together by the implementing card, agent, service or handler.
        <p>
        Each method must have a method name.  It may optionally be marked as <code>optional</code>, meaning that implementers do not need to provide a definition for it.
        It specifies zero or more arguments; these must be typed, and there are restrictions on the types that may be passed.
        It may optionally specify a subscription handler.  This must be a typed variable where the type is a hander contract.
        </p>
      </description>
    </section>
    <tested by='test.parsing.TDAContractIntroParsingTests' />
    <seq>
      <ref production='contract-intro'/>
      <token type='type-name' names='Contract\[${name}\]'/>
      <indent>
      	<ref production='contract-method-decls'/>
      </indent>
    </seq>
  </production>
  <production name='contract-intro'>
    <section title='Contracts'/>
    <tested by='test.parsing.TDAContractIntroParsingTests' />
    <or>
      <seq>
        <token type='CONTRACT'/>
      </seq>
      <seq>
        <token type='CONTRACT'/>
        <token type='SERVICE'/>
      </seq>
      <seq>
        <token type='CONTRACT'/>
        <token type='HANDLER'/>
      </seq>
    </or>  
  </production>
  <production name='contract-method-decls'>
    <section title='Contracts'/>
    <tested by='test.parsing.TDAContractIntroParsingTests' />
    <seq>
      <many>
      	<ref production='contract-method-decl'/>
      </many>
    </seq>
  </production>
  <production name='contract-method-decl'>
    <section title='Contracts'/>
	<tested by='test.parsing.TDAContractMethodParsingTests' />
    <seq>
      <optional>
        <token type='OPTIONAL'/>
      </optional>
      <token type='var-name'/>
      <many>
      	<ref production='argument-pattern-typed'/>
      </many>
      <optional>
        <ref production='handled-by' />
      </optional>
      <token type='EOL' />
    </seq>
  </production>
  <production name='handled-by'>
    <section title='Contracts'/>
	<tested by='test.parsing.TDAContractMethodParsingTests' />
    <seq>
      <token type='HANDLE'/>
      <ref production='argument-pattern-typed' />
    </seq>
  </production>
  <production name='function-case-definition'>
    <section title='Functions'>
	    <description>
	       Constants and functions can be declared either at the top level or within nested scopes.
	       When declared within a nested scope, all the surrounding variables and definitions are available
	       for reference by name.
	       Note that a complete function declaration is made up of multiple cases applying to specific patterns.
	       All of the cases must be declared ``together'' without any intervening blocks, but this is not
	       included in this grammar specification.
	       There are two ways to declare a function case.
	       It is possible to declare a single expression on the same line as the function declaration.
	       Or the function name and argument patterns can appear on one line, and one or more guarded equations
	       can appear on subsequent lines.
	    </description>
	</section>
    <tested by='test.parsing.TDAFunctionParsingTests' />
    <or>
      <ref production='simple-function-case-definition'/>
      <ref production='degenerate-guarded-function-case-definition'/>
      <ref production='guarded-function-case-definition'/>
    </or>
  </production>
  <production name='simple-function-case-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionParsingTests' />
    <seq>
      <token type='var-name' names='FunctionDefinition\[${name}/.*\]' />
      <nested-name offset='1'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <nested-name offset='0'/>
      <token type='EQ'/>
      <ref production='expression'/>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='degenerate-guarded-function-case-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
      <token type='var-name' names='FunctionDefinition\[${name}/.*\]' />
      <nested-name offset='1'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <nested-name offset='0'/>
      <indent-one>
      	<ref production='guarded-default-expression'/>
      </indent-one>
    </seq>
  </production>
  <production name='guarded-function-case-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
      <token type='var-name' names='FunctionDefinition\[${name}/.*\]' />
      <nested-name offset='1'/>
      <many>
      	<ref production='argument-pattern'/>
      </many>
      <nested-name offset='0'/>
      <indent-one>
      	<ref production='guarded-equations'/>
      </indent-one>
    </seq>
  </production>
  <production name='guarded-equations'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
      <one-or-more>
	    <ref production='guarded-expression'/>
	  </one-or-more>
	  <optional>
	    <ref production='guarded-default-expression'/>
	  </optional>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='guarded-expression'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
	    <token type='GUARD'/>
	    <ref production='expression'/>
	    <token type='EQ'/>
	    <ref production='expression'/>
	    <token type='EOL'/>
    </seq>
  </production>
  <production name='guarded-default-expression'>
    <section title='Functions'/>
    <tested by='test.parsing.TDAFunctionGuardedCaseParsingTests' />
    <seq>
	    <token type='EQ'/>
	    <ref production='expression'/>
	    <token type='EOL'/>
    </seq>
  </production>
  <production name='tuple-definition'>
    <section title='Functions'/>
    <tested by='test.parsing.TDATupleDeclarationParsingTests' />
    <seq>
    	  <token type='ORB' />
      <token type='var-name' names='TupleMember\[${name}.*\]' >
      	<named amended='_tuple_${final}' pattern='TupleAssignment\{${final}=&gt;\[.*\]=.*\}' scope='true' />
      </token>
      <one-or-more>
      	<ref production='comma-var-name' />
      </one-or-more>
    	  <token type='CRB' />
      <token type='EQ'/>
      <ref production='expression'/>
      <indent>
      	<ref production='function-scope'/>
      </indent>
    </seq>
  </production>
  <production name='comma-var-name'>
    <section title='Functions' />
    <tested by='test.parsing.TDATupleDeclarationParsingTests' />
    <seq>
      <token type='COMMA' />
      <token type='var-name' names='TupleMember\[${name}.*\]' scope='false'/>
    </seq>
  </production>
  <production name='argument-pattern'>
    <section title='Patterns'>
    	  <description>
    	  </description>
    </section>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <ref production='argument-pattern-variable'/>
      <ref production='argument-pattern-list'/>
      <ref production='argument-pattern-typed'/>
      <ref production='argument-pattern-ctor'/>
    </or>
  </production>
  <production name='argument-pattern-maybe-typed'>
    <section title='Patterns' />
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <ref production='argument-pattern-variable'/>
      <ref production='argument-pattern-typed'/>
    </or>
  </production>
  <production name='argument-pattern-variable'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <token type='var-name' names='VarPattern\[${name}\]' scope='false'/>
  </production>
  <production name='argument-pattern-list'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <seq>
        <token type='OSB'/>
        <token type='CSB'/>
      </seq>
      <seq>
        <token type='OSB'/>
        <ref production='argument-pattern'/>
        <many>
          <ref production='comma-argument-pattern'/>
        </many>
        <token type='CSB'/>
      </seq>
    </or>
  </production>
  <production name='comma-argument-pattern'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='COMMA'/>
      <ref production='argument-pattern'/>
    </seq>
  </production>
  <production name='argument-pattern-typed'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='ORB'/>
      <ref production='type-reference'/>
      <token type='var-name'/>
      <token type='CRB'/>
    </seq>
  </production>
  <production name='argument-pattern-ctor'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <seq>
        <token type='ORB'/>
        <token type='type-name'/>
        <token type='OCB'/>
        <token type='CCB'/>
        <token type='CRB'/>
      </seq>
      <seq>
        <token type='ORB'/>
        <token type='type-name'/>
        <token type='OCB'/>
        <ref production='field-argument-pattern'/>
        <many>
      	  <ref production='comma-field-argument-pattern'/>
        </many>
        <token type='CCB'/>
        <token type='CRB'/>
      </seq>
    </or>
  </production>
  <production name='field-argument-pattern'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='var-name'/>
      <token type='COLON'/>
      <ref production='argument-pattern'/>
    </seq>
  </production>
  <production name='comma-field-argument-pattern'>
    <section title='Patterns'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='COMMA'/>
      <ref production='field-argument-pattern'/>
    </seq>
  </production>
  <production name='type-reference'>
    <section title='Types'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <or>
      <seq>
        <token type='type-name'/>
        <optional>
          <ref production='poly-type-list'/>
        </optional>
      </seq>
      <seq>
        <token type='poly-var'/>
      </seq>
    </or>
  </production>
  <production name='poly-type-list'>
    <section title='Types'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='OSB'/>
      <ref production='type-reference'/>
      <many>
        <ref production='comma-type-reference'/>
      </many>
      <token type='CSB'/>
    </seq>
  </production>
  <production name='comma-type-reference'>
    <section title='Types'/>
    <tested by='test.parsing.TDAPatternParsingTests' />
    <seq>
      <token type='COMMA'/>
      <ref production='type-reference'/>
    </seq>
  </production>
  <production name='expression'>
    <section title='Expressions'>
      <description>
      We need to include . notation for fields, along with the fact that it has very high priority, so should probably be somewhere around the literal stage.
      But we don't particularly focus on operator precedence, so including it as a BINOP and noting that is probably fine.
      </description>
    </section>
    <tested by='test.parsing.ExprReductionTests' />
    <producer shares='50 20 5 10 5 5'/>
    <or>
      <seq>
        <ref production='literal'/>
      </seq>
      <seq>
        <token type='var-name'/>
        <many>
          <ref production='expression'/>
        </many>
      </seq>
      <seq>
        <token type='UNOP'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <ref production='expression'/>
        <token type='BINOP'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <ref production='expression'/>
        <token type='COLON'/>
        <ref production='expression'/>
      </seq>
      <seq>
        <token type='ORB'/>
        <ref production='expression'/>
        <token type='CRB'/>
      </seq>
    </or>
  </production>
  <production name='literal'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprTokenizationTests' />
    <or>
      <token type='NUMBER' />
      <token type='STRING' />
      <token type='TRUE' />
      <token type='FALSE' />
      <ref production='list-literal'/>
      <ref production='object-literal'/>
    </or>
  </production>
  <production name='list-literal'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprReductionTests' />
    <or>
      <seq>
        <token type='OSB' />
        <token type='CSB' />
      </seq>
      <seq>
        <token type='OSB' />
        <ref production='expression' />
        <many>
          <ref production='comma-expression' />
        </many>
        <token type='CSB' />
      </seq>
    </or>
  </production>
  <production name='comma-expression'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprReductionTests' />
    <seq>
      <token type='COMMA' />
      <ref production='expression' />
    </seq>
  </production>
  <production name='object-literal'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprReductionTests' />
    <or>
      <seq>
        <token type='OCB' />
        <token type='CCB' />
      </seq>
      <seq>
        <token type='OCB' />
        <token type='var-name' />
        <token type='COLON' />
        <ref production='expression' />
        <many>
          <ref production='comma-object-member' />
        </many>
        <token type='CCB' />
      </seq>
    </or>
  </production>
  <production name='comma-object-member'>
    <section title='Expressions' />
    <tested by='test.parsing.ExprReductionTests' />
    <seq>
      <token type='COMMA' />
      <token type='var-name' />
      <token type='COLON' />
      <ref production='expression' />
    </seq>
  </production>
  <production name='handler-definition'>
    <section title='Handler'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAHandlerIntroParsingTests' />
    <seq>
      <token type='HANDLER'/>
      <token type='type-name'/>
      <token type='type-name' names='HandlerImplements\[${name}\]'/>
      <nested-name offset='1'/>
      <many>
      	<ref production='argument-pattern-maybe-typed' />
      </many>
      <nested-name offset='0'/>
      <indent>
        <ref production='implementation-method'/>
      </indent>
    </seq>
  </production>
  <production name='standalone-method-definition'>
    <section title='Method'>
      <description>
      Note that standalone and object methods have the same syntax, but they are sufficiently different to make it worth making it clear
      In rule ${message-method-action}, the second case is supposed to represent the user creating either a single <tt>Action</tt> object or a list of them.
      Any other <tt>expression</tt> will end up being rejected at typecheck.
      Note that the first case of the rule is not, per se, a valid expression since the service object is not in scope, but actually it will parse as one.
      </description>
    </section>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <seq>
      <token type='METHOD'/>
      <will-name pattern='StandaloneMethod\[${name}/[0-9]+\]' /> <!-- this will bind to the use-name in the method-definition -->
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='object-method-definition'>
    <section title='Method' />
	<tested by='test.parsing.TDAObjectElementParsingTests' />
	<seq>
      <token type='METHOD'/>
      <will-name pattern='ObjectMethod\[${name}/.*\]' />
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='method-definition'>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <section title='Method'/>
    <seq>
      <token type='var-name'>
      	<use-name/> <!--  this picks up the value from the 'enclosing' will-name -->
      </token>
      <nested-name offset='1'/>
      <many>
        <ref production='argument-pattern'/>
      </many>
      <nested-name offset='0'/>
      <indent>
      	<ref production='method-actions'/>
      </indent>
    </seq>
  </production>
  <production name='method-actions'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
      <many>
        <ref production='method-action'/>
      </many>
      <indent>
        <ref production='function-scope-unit'/>
      </indent>
    </seq>
  </production>
  <production name='method-action'>
    <tested by='test.parsing.TDAMethodNestedParsingTests' />
    <section title='Method'/>
    <or>
      <ref production='message-method-action'/>
      <ref production='assign-method-action'/>
    </or>
  </production>
  <production name='message-method-action'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <or>
      <seq>
      	<token type='SEND' />
      	<ref production='service-method' />
    	    <many>
    	      <ref production='expression' />
    	    </many>
    	    <token type='EOL' />
      </seq>
      <seq>
      	<token type='SEND' />
        <ref production='expression' />
    	    <token type='EOL' />
      </seq>
    </or>
  </production>
  <production name='service-method'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <token type='var-name'/>
    	  <token type='APPLY' />
    	  <token type='var-name'/>
    </seq>
  </production>
  <production name='assign-method-action'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <ref production='member-path' />
    	  <token type='SEND' />
      <ref production='expression' />
    	  <token type='EOL' />
    </seq>
  </production>
  <production name='member-path'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <token type='var-name'/>
    	  <many>
    	    <ref production='member-path-apply'/>
    	  </many>
    </seq>
  </production>
  <production name='member-path-apply'>
    <section title='Method'/>
    <tested by='test.parsing.TDAMethodMessageParsingTests' />
    <seq>
    	  <token type='APPLY' />
    	  <token type='var-name'/>
    </seq>
  </production>
  <production name='object-declaration'>
    <section title='Object'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAObjectIntroParsingTests' />
    <seq>
    	  <token type='OBJECT' />
    	  <token type='type-name' names='ObjectDefinition\[${name}\]' />
    	  <indent-one>
    	    <ref production='object-contents'/>
    	  </indent-one>
    </seq>
  </production>
  <production name='object-contents'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
    	  <ref production='state-declaration'/>
    	  <ref production='many-templates'/>
      <ref production='object-scope-unit'/>
    </seq>
  </production>
  <production name='state-declaration'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
    	  <token type='STATE'/>
    	  <indent>
    	    <ref production='struct-field-list'/>
    	  </indent>
    </seq>
  </production>
  <production name='object-scope-unit'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <producer shares='10 25 25 10 10'/>
    <or>
      <ref production='object-ctor-definition'/>
      <ref production='object-acor-definition'/>
      <ref production='object-method-definition'/>
      <ref production='function-case-definition'/>
      <ref production='handler-definition'/>
    </or>
  </production>
  <production name='object-ctor-definition'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
      <token type='CTOR' />
      <will-name amended='_ctor_${final}' pattern='ObjectCtor\[ctor ${name}\]' /> <!-- this will bind to the use-name in the method-definition -->
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='object-acor-definition'>
    <section title='Object'/>
    <tested by='test.parsing.TDAObjectElementParsingTests' />
    <seq>
      <token type='ACOR' />
      <ref production='function-case-definition'/>
    </seq>
  </production>
  <production name='service-declaration'>
    <section title='Service'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDAServiceParsingTests' />
    <seq>
    	  <token type='SERVICE' />
    	  <token type='type-name' names='Service\[${name}\]' />
    	  <indent-one>
    	    <ref production='service-contents'/>
    	  </indent-one>
    </seq>
  </production>
  <production name='service-contents'>
    <section title='Service'/>
    <tested by='test.parsing.TDAServiceParsingTests' />
    <seq>
    	  <ref production='state-declaration'/>
      <ref production='service-scope'/>
    </seq>
  </production>
  <production name='service-scope'>
    <section title='Service'/>
    <tested by='test.parsing.TDAServiceParsingTests' />
    <many>
      <ref production='service-scope-unit'/>
    </many>
  </production>
  <production name='service-scope-unit'>
    <section title='Service'/>
    <tested by='test.parsing.TDAServiceParsingTests' />
    <or>
    	  <ref production='provides-contract'/>
      <ref production='function-scope-unit'/>
    </or>
  </production>
  <production name='provides-contract'>
    <section title='Service' />
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
    	  <token type='PROVIDES' />
    	  <token type='type-name'/>
    	  <push-part prefix='S' />
    	  <indent>
    	    <ref production='implementation-method'/>
    	  </indent>
    </seq>
  </production>
  <production name='card-declaration'>
    <section title='Card'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
    	  <token type='CARD' />
    	  <token type='type-name' names='Card\[${name}\]'/>
    	  <indent-one>
    	    <ref production='card-contents'/>
    	  </indent-one>
    </seq>
  </production>
  <production name='card-contents'>
    <section title='Card'/>
    <tested by='test.parsing.TDATopLevelCardParsingTests'/>
    <seq>
    	  <ref production='state-declaration'/>
      <ref production='many-templates'/>
      <ref production='card-scope'/>
    </seq>
  </production>
  <production name='card-scope'>
    <section title='Card'/>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <many>
      <ref production='card-scope-unit'/>
    </many>
  </production>
  <production name='card-scope-unit'>
    <section title='Card'/>
    <tested by='test.parsing.TDATopLevelCardParsingTests'/>
    <or>
      <ref production='event-handler'/>
      <ref production='requires-contract'/>
      <ref production='implements-contract'/>
      <ref production='service-scope-unit'/>
    </or>
  </production>
  <production name='requires-contract'>
    <section title='Requires Contract'>
      <description>
        The requires block identifies a contract that this card needs to do its job.
        It requires a contract name and a variable.
        The variable can be used in the card to call the service bound to the contract.
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
      <token type='REQUIRES' />
      <token type='type-name'/>
      <push-part prefix='R' />
      <token type='var-name'/>
    </seq>
  </production>
  <production name='implements-contract'>
    <section title='Implements Contract'>
      <description>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
      <token type='IMPLEMENTS' />
      <token type='type-name'/>
      <push-part prefix='C' />
      <indent>
        <ref production='implementation-method'/>
      </indent>
    </seq>
  </production>
  <production name='implementation-method'>
    <section title='Implements Contract'/>
    <tested by='test.parsing.TDAImplementationMethodsParsingTests' />
    <seq>
      <token type='var-name' names='ObjectMethod\[${name}/[0-9]+\]'/>
      <nested-name offset='1'/>
      <many>
        <ref production='argument-pattern-variable'/>
      </many>
      <optional>
        <ref production='implementation-result'/>
      </optional>
      <nested-name offset='0'/>
      <indent>
      	<ref production='method-actions'/>
      </indent>
    </seq>
  </production>
  <production name='implementation-result'>
    <section title='Implements Contract'/>
    <tested by='test.parsing.TDAImplementationMethodsParsingTests' />
	<seq>
	  <token type='HANDLE'/>
	  <token type='var-name' />
	</seq>    
  </production>
  <production name='event-handler'>
    <section title='Events'>
      <description>
        <p>An event handler is a special type of method on a card, which can respond to UI events.</p>
        <p>Although not part of the grammar, each event will receive an appropriate event object as its final argument.</p>
        <p>Event handlers are not called directly by the system but through the template mechanism (see some rule) and are generally curried, in that some arguments are presented as part of the configuration, and the event itself is provided by the system when called.</p>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <seq>
      <token type='EVENT'/>
      <will-name pattern='ObjectMethod\[${name}/[0-9]+\]' />
      <ref production='method-definition'/>
    </seq>
  </production>
  <production name='many-templates'>
    <section title='Templates'>
      <description>
        <p>Each card can have zero or more templates.  If it has no templates, it cannot have any visual representation.</p>
        <p>If it has at least one template, the first template name must be defined as a <tt>card</tt> in an associated webzip file.  Other templates must be associated with <tt>item</tt>s in a webzip file.</p>
        <p>Each template consists of a set of binding of values to portions of the template.</p>
      </description>
    </section>
    <tested by='test.parsing.TDATopLevelCardParsingTests' />
    <many>
      <ref production='named-template-definition'/>
    </many>
  </production>
  <production name='named-template-definition'>
    <section title='Templates'/>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <seq>
      <token type='TEMPLATE'/>
      <token type='template-name'/>
      <indent>
        <ref production='template-bind'/>
      </indent>
    </seq>
  </production>
  <production name='template-bind'>
    <section title='Template Bindings'>
      <description>
        <p>Each binding is responsible for filling one slot in the template, which can be of type <tt>punnet</tt>, <tt>container</tt> or <tt>content</tt>.</p>
        <p>The first case of rule ${template-bind} enables a value to be "assigned" to a slot in the template.  The exact semantics of this depend on the slot type; see <a href='index.html#connecting-elements-to-cards'>connecting elements to cards</a> for details.</p>
        <p>The second case allows the assignment to be conditional on another expression.  In this case, the conditional (first) expression of each case of rule ${option-template-bind}, which must be of type boolean, is considered and the first one to evaluate to <tt>true</tt> is selected.  The value (second) expression is then used as the value.  The rule ${default-option-template-bind} may be used to specify a default assignment if none of the previous cases match.</p>
        <p>The degenerate (third) case for rule ${template-bind} can only be used to customize <tt>style</tt> elements.  In this case the template name is provided and the styles and events are immediate descendants of this.</p>
        <p>For <tt>container</tt> slots <i>only</i>, it is possible to specify an <tt>item</tt> template that the value should be passed to using rule ${pass-to-template}.</p>
        <p>Styling and event handling may be added to all elements except <tt>punnet</tt>s, which hand off styling and event handling to their contained cards.  In general, this will also not be used with <tt>container</tt> slots.</p>
      </description>
    </section>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <or>
      <seq>
	    <token type='template-name'/>
	    <token type='SEND'/>
	    <ref production='expression'/>
	    <optional>
	    	  <ref production='pass-to-template' />
	    </optional>
        <indent>
          <ref production='template-customization'/>
        </indent>
	  </seq>
      <seq>
	    <token type='template-name'/>
        <indent-one>
          <ref production='option-template-binds'/>
        </indent-one>
	  </seq>
      <seq>
	    <token type='template-name'/>
        <indent-non-zero>
          <ref production='template-customization'/>
        </indent-non-zero>
	  </seq>
    </or>
  </production>
  <production name='option-template-binds'>
    <section title='Template Bindings'/>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <or>
      <seq>
        <one-or-more>
          <ref production='option-template-bind'/>
        </one-or-more>
        <optional>
          <ref production='default-option-template-bind'/>
        </optional>
        <indent>
          <ref production='template-customization'/>
        </indent>
      </seq>
      <seq>
        <ref production='default-option-template-bind'/>
        <indent>
          <ref production='template-customization'/>
        </indent>
      </seq>
    </or>
  </production>
  <production name='option-template-bind'>
    <section title='Template Bindings'/>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <seq>
      <token type='GUARD'/>
	  <ref production='expression'/>
	  <token type='SEND'/>
	  <ref production='expression'/>
	  <optional>
	  	  <ref production='pass-to-template' />
	  </optional>
	  <token type='EOL' />
	</seq>
  </production>
  <production name='default-option-template-bind'>
    <section title='Template Bindings'/>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <seq>
	  <token type='SEND'/>
	  <ref production='expression'/>
	  <optional>
	    <ref production='pass-to-template' />
	  </optional>
	  <token type='EOL' />
	</seq>
  </production>
  <production name='pass-to-template'>
    <section title='Template Bindings'/>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <seq>
      <token type='SENDTO'/>
      <token type='template-name'/>
    </seq>
  </production>
  <production name='template-customization'>
    <section title='Template Customization'>
    		<description>
    			<p>For <tt>content</tt> and <tt>style</tt> elements, it is possible to <i>customize</i> the element by applying styling and adding event handlers.</p>
    			<p>Rule ${template-style} defines the behaviour for styling.  Any number of styling rules may be applied; each will match the <tt>expr</tt> and, if true, will add the classes identified by the strings to the element's class list.</p>
    			<p>Rule ${template-event} defines event handlers.  Each of the predefined events can be mapped exactly once per element.  The outcome will be the invocation of an event handler defined on the card as <tt>var-name</tt>.  It will receive a set of arguments along with an event object of a type appropriate for the named event.</p>
    		</description>
    </section>
    <tested by='test.parsing.TDATemplateParsingTests' />
    <or>
      <ref production="template-style"/>
      <ref production="template-event"/>
    </or>
  </production>
  <production name='template-style'>
    <section title='Template Customization' />
    <tested by='test.parsing.TDATemplateParsingTests' />
    <seq>
      <token type='GUARD'/>
      <ref production='expression'/>
      <token type='SENDTO' />
      <one-or-more>
      	<token type='STRING'/>
      </one-or-more>
    </seq>
  </production>
  <production name='template-event'>
    <section title='Template Customization' />
    <tested by='test.parsing.TDATemplateParsingTests' />
    <seq>
      <token type='event-name' />
      <token type='SENDTO'/>
      <token type='var-name'/>
      <many>
      	<ref production='expression' />
      </many>
    </seq>
  </production>
  <production name='unit-test-unit'>
    <section title='Unit Test Files'>
      <description>
        <p>Unit Tests are built into the FLAS language with special syntax.</p>
        <p>A unit test file in FLAS consists of a number of test and data declarations.</p>
        <p>The test declaration defines a unit test which should be run while the data declaration defines a name for a shared element of test data which can be used in multiple tests.</p>
      </description>
    </section>
    <tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <or>
      <ref production='unit-test-declaration'/>
      <ref production='unit-data-declaration'/>
    </or>
  </production>
  <production name='unit-test-declaration'>
    <section title='Unit Tests'>
      <description>
        <p>Unit Tests are built into the FLAS language with special syntax.</p>
        <p>A unit test in FLAS is defined as being a test either:</p>
        <ul>
        <li>on the behaviour of a function or a standalone method;</li>
        <li>on the behaviour of a service, card or object method when receiving certain input;</li>
        <li>on the display of a card or object template in a given state;</li>
        <li>on the behaviour of a card event handler.</li>
        </ul>
        <p>In order to make all these cases easy, the unit test language allows values and messages to be easily defined and has special syntax for isolating and testing message outputs and template orchestration, independent of the actual template HTML provided.</p>
        <p>The <tt>event</tt> action simulates a UI input event and dispatches it to the card.  The first argument is a variable which is a reference to the card to receive the event.  The second is the name of an event handler. The expression will probably construct an event, but it could also be a reference to a data object.</p>
        <p>The <tt>invoke</tt> action invokes a method on an object.  This is just described as an "expression" but the semantics are that it must be a valid object method invocation.</p>
        <p>The <tt>contract</tt> action is supposed to invoke a method in a contract on a card.  The first argument is a data variable which is a reference to the card to receive the event.  The second argument is the name of the contract which will have the event.  The third var is the name of the method to invoke on the contract.  The expressions are the data elements to send.</p>
        <p>The <tt>expect</tt> action allows expectations to be defined.  This specifies a contract, a method and the arguments that are expected.</p>
        <p>Notes: Expectations should be available on invoke, event and contract. 
           In these expressions you should be able to specify an _ to say that you don't care what goes there or specify a function name which says that it is a matcher which takes one arg and returns a boolean.
           These functions should be nested within the expect block.
           If the pattern matches and true is returned, it's OK. If the patterns don't match and Error is returned, or the function explicitly returns false, the match fails.
           Obviously, we expect exactly all of the expectations to happen.
        </p>
      </description>
    </section>
    <tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <seq>
      <token type='TEST' />
      <one-or-more>
      	<token type='DOCWORD' />
      </one-or-more>
    	  <push-part prefix='ut' />
      <indent>
      	<ref production='unit-test-step'/>
      </indent>
    </seq>
  </production>
  <production name='unit-test-step'>
    <section title='Unit Tests' />
    <tested by='test.parsing.ut.UnitTestStepParsingTests' />
    <or>
      <ref production='unit-data-declaration' />
      <ref production='unit-event-action' />
      <ref production='unit-invoke-action' />
      <ref production='unit-contract-action' />
      <ref production='unit-test-assert' />
      <ref production='unit-test-expect' />
      <ref production='unit-test-template' />
    </or>
  </production>
  <production name='unit-event-action'>
    <section title='Unit Tests' />
    <tested by='test.parsing.ut.UnitTestStepParsingTests' />
    <seq>
      <token type='EVENT' />
      <token type='var-name' /> <!--  the card to receive the event -->
      <token type='event-name' /> <!-- the event name -->
      <ref production='expression' /> <!-- the event object -->
    </seq>
  </production>
  <production name='unit-invoke-action'>
    <section title='Unit Tests' />
    <!--  tested by='test.parsing.ut.UnitTestStepParsingTests' /-->
    <seq>
      <token type='INVOKE' />
      <ref production='expression' /> <!-- I think it's just an expression with a dot in it -->
    </seq>
  </production>
  <production name='unit-contract-action'>
    <section title='Unit Tests' />
    <tested by='test.parsing.ut.UnitTestStepParsingTests' />
    <seq>
      <token type='CONTRACT' />
      <token type='var-name' /> <!--  the card, object or service to receive the action -->
      <token type='type-name' /> <!-- the contract name -->
      <token type='var-name' /> <!--  the contract method -->
      <many>
        <ref production='expression' /> <!-- the arguments -->
      </many>
    </seq>
  </production>
  <production name='unit-test-assert'>
    <section title='Unit Tests' />
    <tested by='test.parsing.ut.UnitTestStepParsingTests' />
    <seq>
      <token type='ASSERT' />
      <ref production='expression' />
      <indent-one>
    	    <ref production='expression' />
      </indent-one>
    </seq>
  </production>
  <production name='unit-test-expect'>
    <section title='Unit Tests' />
    <tested by='test.parsing.ut.UnitTestStepParsingTests' />
    <seq>
      <token type='EXPECT' />
      <token type='var-name' />
      <token type='var-name' />
      <many>
    	    <ref production='expression' />
      </many>
      <!-- should have an indent block that enables matching functions to be defined  -->
    </seq>
  </production>
  <production name='unit-test-template'>
    <section title='Unit Tests' />
    <seq>
      <token type='TEMPLATE' />
      <!--  as with the template definitions before, I'm not really sure what comes here ... -->
      <!--  I do know I want it to be as independent of HTML as possible, and thus close to the syntax used for specifying them -->
      <!--  but obviously I want something disconnected from the actual logic -->
    </seq>
  </production>
  <production name='unit-data-declaration'>
    <section title='Unit Test Data'>
      <description>
        <p>Declare a variable in test scope either as the result of a simple expression or by creating a compound object with field assignments.</p>
        <i>I feel the expression case possibly needs to be expanded to allow for object constructors to be invoked.</i>
      </description>
    </section>
    <tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <or>
      <ref production='unit-expr-data-declaration' />
      <ref production='unit-fields-data-declaration' />
    </or>
  </production>
  <production name='unit-expr-data-declaration'>
    <section title='Unit Test Data' />
    <tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <seq>
      <token type='DATA' />
      <ref production='type-reference' />
      <token type='var-name' names='UnitData\[${name}.*\]' />
      <token type='SEND' />
      <ref production='expression' />
      <token type='EOL' />
    </seq>
  </production>
  <production name='unit-fields-data-declaration'>
    <section title='Unit Test Data' />
    <tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <seq>
      <token type='DATA' />
      <ref production='type-reference' />
      <token type='var-name'  names='UnitData\[${name}.*\]' />
      <indent-non-zero>
        <ref production='unit-fields-data-initializer' />
      </indent-non-zero>
    </seq>
  </production>
  <production name='unit-fields-data-initializer'>
    <section title='Unit Test Data' />
    <tested by='test.parsing.ut.UnitTestTopLevelParsingTests' />
    <seq>
      <token type='var-name' />
      <token type='SEND' />
      <ref production='expression' />
      <token type='EOL' />
    </seq>
  </production>
  <production name='protocol-test-unit'>
    <section title='Protocol Tests'>
      <description>
      <p>Much of what defines FLAS is the concept of the contract.</p>
      <p>There are many implementations of any given contract, but there should be certain characteristics common to all implementations of a contract.</p>
      <p>The purpose of protocol tests is to verify that for any given contract, all the implementations of the contract obey those invariants.</p>
      <p>Thus protocol tests are written in the context of a contract in a given direction, but then automatically applied to all implementations of that contract: objects, services and cards.</p>
      <i>informally, basically, I just want to say that if you do this sequence of things to a contract, it will respond appropriately.  It's more complex than that, but hopefully when I have some real examples, it will become clear.</i>
      </description>
    </section>
    <token type='GUARD' />
  </production>
  <production name='system-test-unit'>
    <section title='System Tests'>
      <description>
      <p>System tests define end-to-end storyboard tests.</p>
      <p>They can come in two varieties: with or without a backend.</p>
      <p>In either case, the actions of both ends are actually defined in the test, it's just a question of where the service layer stops and is replaced by "mocks" implemented in the test.</p>
      <i>I haven't really thought this through, but I'm sure it will again become apparent when I want to write one.</i>
      </description>
    </section>
    <token type='GUARD' />
  </production>
</grammar>