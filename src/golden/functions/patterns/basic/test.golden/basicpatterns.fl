// Nil->Number
	a Nil = 0

// Cons->Number
	a2 (Cons x) = 1

// Cons->Number
a3 (Cons {head: a}) = a

// Boolean->Number
	b True = 0
	b False = 1

// Number->Number
c 0 = 0
c n = n - 1

// Any->Number
d Nil = 0
d x = 1

// Cons[Any,Any]->Number
e (Cons Nil Nil) = 0
e (Cons x y) = 1

// Number->Number
f 3 = 0

// String->Number
g "hello" = 1

// Number->Number
h (Number x) = 5

// Any->Number
	k x = 0
	
// Number->Number
	l (Number x) = 0
	
... polymorphic ones need to go elsewhere (polypatterns.fl?)